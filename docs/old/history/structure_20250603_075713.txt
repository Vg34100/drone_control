Scan Report
===========
Date: 2025-06-03 07:57:13
Source Directory: C:\Users\video\The Studio\Downloads\drone_control
Output File: C:\Users\video\The Studio\Downloads\drone_control\docs\history\structure_20250603_075713.txt

Ignored Patterns:
================
- **/*.log
- **/*.patch
- **/*/__pycache__/*
- **/.vscode
- **/docs/history/*
- **/test/*
- **/venv
- *.log
- *.patch
- */__pycache__/*
- .vscode
- docs/history/*
- test/*
- venv

Directory Structure:
===================

drone_control/
  main.py
  path_walker.py
  debug/
    bullseye_test.py
    debug_position.py
    message_rate_diagnostic.py
    test_position_tracking.py
  debug_frames/
  detection/
    bullseye_detector.py
    camera.py
    gcp.py
    models.py
    video_recorder.py
  docs/
  drone/
    connection.py
    navigation.py
    servo.py
  missions/
    delivery.py
    test_missions.py
    waypoint.py
  models/
  recordings/


File Contents:
=============


--- main.py ---
#!/usr/bin/env python3
"""
main.py - IMPROVED VERSION WITH VIDEO RECORDING & BULLSEYE DETECTION
Drone Control System - Main Launcher
-----------------------------------
This script serves as the main entry point for all drone operations.
It parses command-line arguments to determine which mission to run.
"""

import argparse
import sys
import logging
import time
from typing import Dict, Callable, Any
from pymavlink import mavutil

# Import modules
from drone.connection import connect_vehicle, close_vehicle
from drone.navigation import set_mode, test_motors
from drone.servo import test_servo_simple
from missions.test_missions import (
    test_connection, test_arm, test_takeoff, test_camera, test_detection,
    test_motor, test_incremental_takeoff, monitor_altitude_realtime
)
from missions.waypoint import (
    mission_diamond_precision_fixed, mission_waypoint, mission_waypoint_detect
)
from missions.delivery import (
    mission_package_delivery, mission_package_drop, mission_target_localize
)
from detection.video_recorder import create_video_recorder
from detection.bullseye_detector import test_bullseye_detection

class MissionConfig:
    """Configuration class for mission parameters and shortcuts"""

    # Mission aliases mapping - maps shortcuts to primary mission names
    MISSION_ALIASES = {
        # Connection tests
        "test-connection": ["conn", "c", "1"],
        "preflight-all": ["pre", "p", "0"],
        "reset-controller": ["reset", "r", "2"],

        # Takeoff tests
        "incremental-takeoff": ["t-t", "inc-takeoff"],
        "diamond-waypoints": ["t-w", "diamond"],

        # Quick access shortcuts
        "test-arm": ["arm", "a"],
        "test-motor": ["motor", "m"],
        "test-camera": ["cam", "camera"],
        "test-servo": ["servo", "s"],
        "test-takeoff": ["takeoff", "to"],

        # NEW: Bullseye detection test
        "test-bullseye-video": ["bullseye", "bull", "b", "target"],

        # NEW: Video recording test
        "test-video-recording": ["record-test", "rec-test", "video-test"],

        # Advanced missions
        "waypoint": ["wp", "way"],
        "package-delivery": ["delivery", "del"],
        "package-drop": ["drop", "pd"],
        "target-localize": ["localize", "loc"],

        # Diagnostics
        "diagnostics": ["diag", "d"],
        "check-altitude": ["alt", "altitude"],
        "safety-check": ["safety", "safe"],
        "orientation-check": ["orient", "orientation"],
        "position-hold-check": ["pos-hold", "position"],
    }

    # Reverse mapping for quick lookup
    ALIAS_TO_MISSION = {}
    for mission, aliases in MISSION_ALIASES.items():
        ALIAS_TO_MISSION[mission] = mission  # Add the primary name
        for alias in aliases:
            ALIAS_TO_MISSION[alias] = mission

class DroneController:
    """Main drone controller class"""

    def __init__(self):
        self.vehicle = None
        self.config = MissionConfig()
        self.mission_handlers = self._setup_mission_handlers()
        self.video_recorder = None

    def _setup_mission_handlers(self) -> Dict[str, Callable]:
        """Setup mission handler mapping"""
        return {
            # Connection and diagnostics
            "test-connection": self._handle_test_connection,
            "preflight-all": self._handle_preflight_all,
            "reset-controller": self._handle_reset_controller,
            "diagnostics": self._handle_diagnostics,

            # Basic tests
            "test-arm": self._handle_test_arm,
            "test-motor": self._handle_test_motor,
            "test-camera": self._handle_test_camera,
            "test-servo": self._handle_test_servo,
            "test-detect": self._handle_test_detect,

            # NEW: Bullseye detection test
            "test-bullseye-video": self._handle_test_bullseye_video,

            # NEW: Video recording test
            "test-video-recording": self._handle_test_video_recording,

            # Takeoff tests
            "test-takeoff": self._handle_test_takeoff,
            "incremental-takeoff": self._handle_incremental_takeoff,
            "diamond-waypoints": self._handle_diamond_waypoints,

            # Navigation missions
            "waypoint": self._handle_waypoint,
            "waypoint-detect": self._handle_waypoint_detect,

            # Delivery missions
            "package-delivery": self._handle_package_delivery,
            "package-drop": self._handle_package_drop,
            "target-localize": self._handle_target_localize,

            # System controls
            "fix-mode": self._handle_fix_mode,

            # Safety checks
            "safety-check": self._handle_safety_check,
            "orientation-check": self._handle_orientation_check,
            "position-hold-check": self._handle_position_hold_check,
            "check-altitude": self._handle_check_altitude,
        }

    def setup_logging(self):
        """Configure logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='drone_mission.log'
        )
        console = logging.StreamHandler()
        console.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        console.setFormatter(formatter)
        logging.getLogger('').addHandler(console)

    def create_parser(self) -> argparse.ArgumentParser:
        """Create and configure argument parser"""
        parser = argparse.ArgumentParser(
            description="Drone Mission Control System",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self._get_help_epilog()
        )

        # Get all possible mission choices (primary names + aliases)
        all_choices = list(self.config.ALIAS_TO_MISSION.keys())

        parser.add_argument(
            "mission",
            choices=all_choices,
            help="Mission to execute (use -h to see shortcuts)"
        )

        # Mission parameters
        parser.add_argument("--altitude", type=float, default=3.0,
                          help="Target altitude in meters")
        parser.add_argument("--connection", type=str, default="tcp:127.0.0.1:5761",
                          help="Connection string for the vehicle")
        parser.add_argument("--model", type=str, default="models/latest.pt",
                          help="Path to the detection model")
        parser.add_argument("--duration", type=float, default=1.0,
                          help="Duration for motor testing")
        parser.add_argument("--throttle", type=float, default=15.0,
                          help="Throttle percentage for motor testing (0-100)")
        parser.add_argument("--increment", type=float, default=1.0,
                          help="Height increment in meters for incremental takeoff")
        parser.add_argument("--loops", type=int, default=1,
                          help="Number of times to repeat the mission")

        # NEW: Video recording options
        parser.add_argument("--record", action="store_true",
                          help="Record video during mission execution")
        parser.add_argument("--record-fps", type=float, default=30.0,
                          help="Recording frame rate (default: 30 FPS)")
        parser.add_argument("--record-dir", type=str, default="recordings",
                          help="Directory to save recordings (default: recordings)")

        # NEW: Bullseye detection options
        parser.add_argument("--source", type=str, default="0",
                          help="Camera ID, video file, or image file for bullseye detection")
        parser.add_argument("--display", action="store_true", default=True,
                          help="Display detection results (default: True)")
        parser.add_argument("--no-display", dest="display", action="store_false",
                          help="Disable display of detection results")
        parser.add_argument("--save-results", action="store_true", default=True,
                          help="Save detection results (default: True)")
        parser.add_argument("--no-save", dest="save_results", action="store_false",
                          help="Disable saving of detection results")
        parser.add_argument("--video-delay", type=float, default=0.1,
                          help="Delay between video frames in seconds (default: 0.1)")

        return parser

    def _get_help_epilog(self) -> str:
        """Generate help text showing mission shortcuts"""
        lines = ["\nMission Shortcuts:"]
        lines.append("=" * 50)

        for mission, aliases in self.config.MISSION_ALIASES.items():
            if aliases:  # Only show if there are aliases
                aliases_str = ", ".join(aliases)
                lines.append(f"  {mission:<20} → {aliases_str}")

        lines.append("\nExamples:")
        lines.append("  python main.py c              # test-connection")
        lines.append("  python main.py pre --altitude 5  # preflight-all at 5m")
        lines.append("  python main.py t-t --increment 0.5  # incremental takeoff")
        lines.append("  python main.py diamond --loops 3    # 3 diamond loops")
        lines.append("  python main.py diamond --record     # record video during mission")
        lines.append("  python main.py bullseye --source video.mp4  # detect bullseyes in video")
        lines.append("  python main.py bull --source image.jpg --no-display  # process image without display")
        lines.append("  python main.py record-test --duration 15  # test video recording for 15 seconds")
        lines.append("  python main.py rec-test --source 1 --duration 30  # test camera 1 for 30 seconds")

        return "\n".join(lines)

    def connect_if_needed(self, mission: str, connection_string: str) -> bool:
        """Connect to vehicle if the mission requires it"""
        # Resolve mission alias to primary name FIRST
        primary_mission = self.config.ALIAS_TO_MISSION.get(mission, mission)

        missions_without_vehicle = {
            "test-camera",
            "test-bullseye-video",
            "test-video-recording"  # NEW: For testing video recording without vehicle
        }

        if primary_mission in missions_without_vehicle:
            logging.info(f"Mission '{primary_mission}' does not require vehicle connection")
            return True

        logging.info(f"Connecting to vehicle at {connection_string}")
        self.vehicle = connect_vehicle(connection_string)

        if not self.vehicle:
            logging.error("Failed to connect to vehicle")
            return False

        return True

    def start_recording_if_requested(self, args, mission_name: str) -> bool:
        """Start video recording if requested"""
        if not args.record:
            return True

        logging.info("Starting video recording...")
        self.video_recorder = create_video_recorder(
            output_dir=args.record_dir,
            fps=args.record_fps
        )

        success = self.video_recorder.start_recording(
            camera_id=0,
            mission_name=mission_name
        )

        if success:
            logging.info(f"Recording started for mission: {mission_name}")
        else:
            logging.error("Failed to start video recording")
            self.video_recorder = None

        return success

    def stop_recording_if_active(self):
        """Stop video recording if active"""
        if self.video_recorder and self.video_recorder.is_recording():
            logging.info("Stopping video recording...")
            success = self.video_recorder.stop_recording()
            if success:
                logging.info("Video recording stopped successfully")
            else:
                logging.error("Error stopping video recording")
            self.video_recorder = None

    def execute_mission(self, mission: str, args: argparse.Namespace) -> bool:
        """Execute the specified mission"""
        # Resolve mission alias to primary name
        primary_mission = self.config.ALIAS_TO_MISSION.get(mission, mission)

        # Get handler for the mission
        handler = self.mission_handlers.get(primary_mission)

        if not handler:
            logging.error(f"Unknown mission: {mission}")
            return False

        logging.info(f"Executing mission: {primary_mission} (alias: {mission})")

        try:
            # Start recording if requested (except for standalone test missions)
            standalone_missions = {"test-camera", "test-bullseye-video", "test-video-recording"}
            if primary_mission not in standalone_missions:
                if not self.start_recording_if_requested(args, primary_mission):
                    logging.warning("Continuing mission without recording")

            # Execute the mission
            result = handler(args)

            return result

        except Exception as e:
            logging.exception(f"Mission '{primary_mission}' failed with error: {str(e)}")
            return False
        finally:
            # Always stop recording when mission ends
            self.stop_recording_if_active()

    # Mission handler methods
    def _handle_test_connection(self, args) -> bool:
        return test_connection(self.vehicle)

    def _handle_test_arm(self, args) -> bool:
        return test_arm(self.vehicle)

    def _handle_test_takeoff(self, args) -> bool:
        return test_takeoff(self.vehicle, args.altitude)

    def _handle_test_camera(self, args) -> bool:
        return test_camera()

    def _handle_test_detect(self, args) -> bool:
        return test_detection(args.model)

    def _handle_test_motor(self, args) -> bool:
        return test_motor(self.vehicle, args.throttle, args.duration)

    def _handle_test_servo(self, args) -> bool:
        return test_servo_simple(self.vehicle)

    def _handle_test_bullseye_video(self, args) -> bool:
        """Handle bullseye detection test"""
        # Convert source to appropriate type
        source = args.source
        try:
            # Try to convert to int (camera ID)
            source = int(source)
        except ValueError:
            # Keep as string (file path)
            pass

        return test_bullseye_detection(
            source=source,
            display=args.display,
            save_results=args.save_results,
            duration=args.duration if isinstance(source, int) else 0,
            video_delay=args.video_delay
        )

    def _handle_test_video_recording(self, args) -> bool:
        """Handle video recording test (no vehicle required)"""
        from detection.video_recorder import test_video_recording

        # Convert source to camera ID if it's a digit
        camera_id = 0
        try:
            camera_id = int(args.source)
        except ValueError:
            logging.warning(f"Invalid camera ID '{args.source}', using camera 0")

        return test_video_recording(
            camera_id=camera_id,
            duration=args.duration if args.duration > 1 else 10,  # Default 10 seconds
            output_dir=args.record_dir
        )

    def _handle_incremental_takeoff(self, args) -> bool:
        return test_incremental_takeoff(self.vehicle, args.altitude, args.increment)

    def _handle_diamond_waypoints(self, args) -> bool:
        return mission_diamond_precision_fixed(self.vehicle, args.altitude, args.loops)

    def _handle_waypoint(self, args) -> bool:
        return mission_waypoint(self.vehicle, args.altitude)

    def _handle_waypoint_detect(self, args) -> bool:
        return mission_waypoint_detect(self.vehicle, args.altitude, args.model)

    def _handle_package_delivery(self, args) -> bool:
        return mission_package_delivery(self.vehicle, args.altitude, args.model)

    def _handle_package_drop(self, args) -> bool:
        return mission_package_drop(self.vehicle, args.altitude, args.model)

    def _handle_target_localize(self, args) -> bool:
        return mission_target_localize(self.vehicle, args.altitude)

    def _handle_fix_mode(self, args) -> bool:
        if not self.vehicle:
            logging.error("Vehicle connection required for fix-mode")
            return False

        success = set_mode(self.vehicle, "LOITER")
        if success:
            logging.info("Successfully changed vehicle mode to LOITER")
        else:
            logging.error("Failed to change vehicle mode")
        return success

    def _handle_diagnostics(self, args) -> bool:
        from drone.connection import get_vehicle_diagnostics
        diagnostics = get_vehicle_diagnostics(self.vehicle, timeout=10)
        if diagnostics:
            logging.info("Diagnostics complete - see log for details")
            return True
        else:
            logging.error("Failed to get diagnostics")
            return False

    def _handle_reset_controller(self, args) -> bool:
        from drone.connection import reset_flight_controller
        success = reset_flight_controller(self.vehicle)
        if success:
            logging.info("Reset command sent to flight controller")
        else:
            logging.error("Failed to send reset command")
        return success

    def _handle_safety_check(self, args) -> bool:
        from drone.navigation import run_preflight_checks
        checks_passed, failure_reason = run_preflight_checks(self.vehicle)
        if not checks_passed:
            logging.error(f"Safety checks failed: {failure_reason}")
        else:
            logging.info("All safety checks passed!")
        return checks_passed

    def _handle_orientation_check(self, args) -> bool:
        from drone.navigation import verify_orientation
        success = verify_orientation(self.vehicle)
        if success:
            logging.info("Orientation is stable and suitable for takeoff")
        else:
            logging.warning("Orientation may be unstable - use caution")
        return success

    def _handle_position_hold_check(self, args) -> bool:
        from drone.navigation import verify_position_hold
        return verify_position_hold(self.vehicle)

    def _handle_check_altitude(self, args) -> bool:
        success = monitor_altitude_realtime(self.vehicle, duration=0)
        if success:
            logging.info("Altitude monitoring completed")
        else:
            logging.error("Altitude monitoring failed")
        return success

    def _handle_preflight_all(self, args) -> bool:
        """Run comprehensive preflight checks"""
        logging.info("Running comprehensive preflight checks...")

        checks = [
            ("Connection Test", lambda: test_connection(self.vehicle)),
            ("Arm Test", lambda: test_arm(self.vehicle)),
            ("Motor Test", lambda: test_motor(self.vehicle, args.throttle)),
            ("Safety Checks", self._handle_safety_check),
            ("Orientation Check", self._handle_orientation_check),
            ("Position Hold Check", self._handle_position_hold_check),
        ]

        results = []
        for check_name, check_func in checks:
            logging.info(f"Running {check_name}...")
            try:
                result = check_func(args) if check_name in ["Safety Checks", "Orientation Check", "Position Hold Check"] else check_func()
                results.append((check_name, result))
                logging.info(f"{check_name}: {'PASSED' if result else 'FAILED'}")
                time.sleep(2)  # Brief pause between checks
            except Exception as e:
                logging.error(f"{check_name} failed with exception: {str(e)}")
                results.append((check_name, False))

        # Summary
        passed = sum(1 for _, result in results if result)
        total = len(results)

        logging.info(f"\nPreflight Summary: {passed}/{total} checks passed")
        for check_name, result in results:
            status = "✓ PASS" if result else "✗ FAIL"
            logging.info(f"  {check_name}: {status}")

        return passed == total

    def cleanup(self):
        """Clean up resources"""
        # Stop recording if active
        self.stop_recording_if_active()

        # Close vehicle connection
        if self.vehicle:
            close_vehicle(self.vehicle)
            logging.info("Mission clean-up completed")

    def run(self) -> int:
        """Main execution method"""
        try:
            self.setup_logging()
            parser = self.create_parser()
            args = parser.parse_args()

            # Connect to vehicle if needed
            if not self.connect_if_needed(args.mission, args.connection):
                return 1

            # Execute mission
            success = self.execute_mission(args.mission, args)

            if success:
                logging.info(f"Mission '{args.mission}' completed successfully")
                return 0
            else:
                logging.error(f"Mission '{args.mission}' failed")
                return 1

        except KeyboardInterrupt:
            logging.warning("Mission aborted by user")
            return 130
        except Exception as e:
            logging.exception(f"Unexpected error: {str(e)}")
            return 1
        finally:
            self.cleanup()

def main():
    """Entry point"""
    controller = DroneController()
    return controller.run()

if __name__ == "__main__":
    sys.exit(main())


--- path_walker.py ---
import os
from datetime import datetime
import fnmatch
from pathlib import Path

def load_gitignore(path):
    """Load .gitignore patterns and convert them to proper glob patterns"""
    gitignore_patterns = set()
    gitignore_path = os.path.join(path, '.gitignore')

    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    pattern = line.replace('\\', '/')
                    if pattern.endswith('/'):
                        pattern = f"**/{pattern}**"
                    else:
                        pattern = f"**/{pattern}"
                    gitignore_patterns.add(pattern)
                    if pattern.startswith('**/'):
                        gitignore_patterns.add(pattern[3:])

    return gitignore_patterns

def should_ignore(path, base_path, gitignore_patterns, custom_patterns=None):
    """Check if a path should be ignored using glob patterns"""
    try:
        rel_path = os.path.relpath(path, base_path).replace('\\', '/')
        filename = os.path.basename(path)
    except ValueError:
        return False

    if '.git' in Path(rel_path).parts:
        return True

    # Check custom patterns first
    if custom_patterns:
        for pattern in custom_patterns:
            if fnmatch.fnmatch(filename, pattern):
                return True

    # Then check gitignore patterns
    for pattern in gitignore_patterns:
        if fnmatch.fnmatch(rel_path, pattern):
            return True

        path_parts = Path(rel_path).parts
        for i in range(len(path_parts)):
            partial_path = '/'.join(path_parts[:i+1])
            if fnmatch.fnmatch(partial_path, pattern):
                return True
            if fnmatch.fnmatch(f"{partial_path}/", pattern):
                return True

    return False

def print_directory_structure(startpath, output_file, accepted=('.ts', '.tsx', '.py'), custom_ignore_patterns=None):
    """
    Print directory structure to a file.

    Args:
        startpath: Path to start scanning from
        output_file: Output file path
        accepted: Tuple of accepted file extensions
        custom_ignore_patterns: List of additional patterns to ignore (e.g., ['Lab*', 'test*'])
    """
    startpath = os.path.abspath(startpath)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Load gitignore patterns
    gitignore_patterns = load_gitignore(startpath)

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(f"Scan Report\n")
        f.write(f"===========\n")
        f.write(f"Date: {timestamp}\n")
        f.write(f"Source Directory: {startpath}\n")
        f.write(f"Output File: {os.path.abspath(output_file)}\n\n")

        if gitignore_patterns or custom_ignore_patterns:
            f.write("Ignored Patterns:\n")
            f.write("================\n")
            if gitignore_patterns:
                for pattern in sorted(gitignore_patterns):
                    f.write(f"- {pattern}\n")
            if custom_ignore_patterns:
                for pattern in sorted(custom_ignore_patterns):
                    f.write(f"- {pattern}\n")
            f.write("\n")

        f.write("Directory Structure:\n")
        f.write("===================\n\n")

        for root, dirs, files in os.walk(startpath):
            if should_ignore(root, startpath, gitignore_patterns, custom_ignore_patterns):
                dirs[:] = []
                continue

            try:
                level = len(Path(root).relative_to(Path(startpath)).parts)
            except ValueError:
                level = 0

            indent = '  ' * level
            f.write(f'{indent}{os.path.basename(root)}/\n')

            visible_files = []
            for file in sorted(files):
                full_path = os.path.join(root, file)
                if (file.endswith(accepted) and
                    not should_ignore(full_path, startpath, gitignore_patterns, custom_ignore_patterns)):
                    visible_files.append(file)

            subindent = '  ' * (level + 1)
            for file in visible_files:
                f.write(f'{subindent}{file}\n')

            i = 0
            while i < len(dirs):
                dir_path = os.path.join(root, dirs[i])
                if should_ignore(dir_path, startpath, gitignore_patterns, custom_ignore_patterns):
                    dirs.pop(i)
                else:
                    i += 1

        f.write("\n\nFile Contents:\n")
        f.write("=============\n\n")

        for root, dirs, files in os.walk(startpath):
            if should_ignore(root, startpath, gitignore_patterns, custom_ignore_patterns):
                continue

            for file in sorted(files):
                if not file.endswith(accepted):
                    continue

                full_path = os.path.join(root, file)
                if should_ignore(full_path, startpath, gitignore_patterns, custom_ignore_patterns):
                    continue

                rel_path = os.path.relpath(full_path, startpath)
                f.write(f"\n--- {rel_path} ---\n")
                try:
                    with open(full_path, 'r', encoding='utf-8') as file_content:
                        f.write(file_content.read())
                except Exception as e:
                    f.write(f"\nError reading file: {str(e)}\n")
                f.write("\n")

# Ensure docs/history folder exists
os.makedirs('docs/history', exist_ok=True)

# Add timestamp to the output file names
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
output_file = f'docs/history/structure_{timestamp}.txt'

print_directory_structure(
    '',
    output_file,
    accepted=('.py'),
    custom_ignore_patterns=[]  # Add any patterns you want to ignore
)


--- debug\bullseye_test.py ---
# FILE: bullseye_video_test.py
# New script for testing bullseye detection on video files
# Optimized for drone competition use with Jetson Orin Nano

import cv2
import time
import argparse
from pathlib import Path
from ultralytics import YOLO
import numpy as np

class BullseyeVideoTester:
    def __init__(self, model_path="models/best.pt", confidence_threshold=0.5, imgsz=160):
        """
        Initialize the bullseye detector

        Args:
            model_path: Path to the YOLO model file
            confidence_threshold: Minimum confidence for detections
            imgsz: Input image size for the model
        """
        print(f"Loading model: {model_path}")
        self.model = YOLO(model_path)
        self.conf_threshold = confidence_threshold
        self.imgsz = imgsz

        # Performance tracking
        self.frame_count = 0
        self.total_inference_time = 0
        self.detections_count = 0

    def detect_bullseyes(self, frame):
        """
        Detect bullseyes in a single frame

        Args:
            frame: Input frame (BGR format)

        Returns:
            annotated_frame: Frame with bounding boxes drawn
            detections: List of detection dictionaries
        """
        start_time = time.time()

        # Run inference
        results = self.model.predict(frame, imgsz=self.imgsz, conf=self.conf_threshold, verbose=False)

        inference_time = time.time() - start_time
        self.total_inference_time += inference_time
        self.frame_count += 1

        # Process results
        detections = []
        annotated_frame = frame.copy()

        for result in results:
            if result.boxes is not None:
                for box in result.boxes:
                    # Extract box coordinates and confidence
                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                    confidence = float(box.conf[0])

                    # Store detection info
                    detection = {
                        'bbox': (x1, y1, x2, y2),
                        'confidence': confidence,
                        'center': ((x1 + x2) // 2, (y1 + y2) // 2)
                    }
                    detections.append(detection)
                    self.detections_count += 1

                    # Draw bounding box
                    cv2.rectangle(annotated_frame, (x1, y1), (x2, y2), (0, 255, 0), 2)

                    # Draw center point
                    center = detection['center']
                    cv2.circle(annotated_frame, center, 5, (255, 0, 0), -1)

                    # Add confidence label
                    label = f"Bullseye: {confidence:.3f}"
                    label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)[0]
                    cv2.rectangle(annotated_frame, (x1, y1 - label_size[1] - 10),
                                (x1 + label_size[0], y1), (0, 255, 0), -1)
                    cv2.putText(annotated_frame, label, (x1, y1 - 5),
                              cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)

        # Add frame info
        fps = 1.0 / inference_time if inference_time > 0 else 0
        info_text = f"FPS: {fps:.1f} | Detections: {len(detections)} | Frame: {self.frame_count}"
        cv2.putText(annotated_frame, info_text, (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

        # Add crosshair at frame center for drone alignment reference
        h, w = annotated_frame.shape[:2]
        cv2.line(annotated_frame, (w//2 - 20, h//2), (w//2 + 20, h//2), (0, 0, 255), 2)
        cv2.line(annotated_frame, (w//2, h//2 - 20), (w//2, h//2 + 20), (0, 0, 255), 2)

        return annotated_frame, detections

    def process_video(self, video_path, output_path=None, display=True, save_video=False):
        """
        Process video file and detect bullseyes

        Args:
            video_path: Path to input video file
            output_path: Path for output video (if save_video=True)
            display: Whether to display video while processing
            save_video: Whether to save annotated video
        """
        print(f"Processing video: {video_path}")

        # Open video
        cap = cv2.VideoCapture(str(video_path))
        if not cap.isOpened():
            raise ValueError(f"Could not open video: {video_path}")

        # Get video properties
        fps = int(cap.get(cv2.CAP_PROP_FPS))
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

        print(f"Video specs: {width}x{height} @ {fps}fps, {total_frames} frames")

        # Setup video writer if saving
        if save_video and output_path:
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(str(output_path), fourcc, fps, (width, height))

        # Process frames
        all_detections = []

        try:
            while True:
                ret, frame = cap.read()
                if not ret:
                    break

                # Detect bullseyes
                annotated_frame, detections = self.detect_bullseyes(frame)
                all_detections.extend(detections)

                # Save frame if requested
                if save_video and output_path:
                    out.write(annotated_frame)

                # Display frame
                if display:
                    # Resize for display if frame is too large
                    display_frame = annotated_frame
                    if width > 1280:
                        scale = 1280 / width
                        new_width = int(width * scale)
                        new_height = int(height * scale)
                        display_frame = cv2.resize(annotated_frame, (new_width, new_height))

                    cv2.imshow('Bullseye Detection', display_frame)

                    # Controls: 'q' to quit, 'p' to pause, space to continue
                    key = cv2.waitKey(1) & 0xFF
                    if key == ord('q'):
                        break
                    elif key == ord('p'):
                        cv2.waitKey(0)  # Wait for any key

                # Progress indicator
                if self.frame_count % 30 == 0:
                    progress = (self.frame_count / total_frames) * 100
                    print(f"Progress: {progress:.1f}% ({self.frame_count}/{total_frames})")

        finally:
            # Cleanup
            cap.release()
            if save_video and output_path:
                out.release()
            if display:
                cv2.destroyAllWindows()

        # Print summary
        self.print_summary(all_detections)

    def process_camera(self, camera_id=0):
        """
        Process live camera feed (for testing with drone camera)

        Args:
            camera_id: Camera device ID (0 for default camera)
        """
        print(f"Starting camera feed from device {camera_id}")
        print("Controls: 'q' to quit, 's' to save screenshot")

        cap = cv2.VideoCapture(camera_id)
        if not cap.isOpened():
            raise ValueError(f"Could not open camera {camera_id}")

        # Set camera properties (adjust for your drone camera)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        cap.set(cv2.CAP_PROP_FPS, 30)

        screenshot_count = 0

        try:
            while True:
                ret, frame = cap.read()
                if not ret:
                    print("Failed to grab frame")
                    break

                # Flip frame horizontally for better user experience
                frame = cv2.flip(frame, 1)

                # Detect bullseyes
                annotated_frame, detections = self.detect_bullseyes(frame)

                # Display
                cv2.imshow('Live Bullseye Detection', annotated_frame)

                # Handle keys
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('s'):
                    screenshot_path = f"bullseye_screenshot_{screenshot_count:03d}.jpg"
                    cv2.imwrite(screenshot_path, annotated_frame)
                    print(f"Screenshot saved: {screenshot_path}")
                    screenshot_count += 1

        finally:
            cap.release()
            cv2.destroyAllWindows()

        self.print_summary([])

    def print_summary(self, all_detections):
        """Print performance summary"""
        print("\n" + "="*50)
        print("DETECTION SUMMARY")
        print("="*50)
        print(f"Total frames processed: {self.frame_count}")
        print(f"Total detections: {self.detections_count}")
        print(f"Average detections per frame: {self.detections_count/max(1, self.frame_count):.2f}")

        if self.total_inference_time > 0:
            avg_fps = self.frame_count / self.total_inference_time
            avg_inference_ms = (self.total_inference_time / self.frame_count) * 1000
            print(f"Average FPS: {avg_fps:.1f}")
            print(f"Average inference time: {avg_inference_ms:.1f}ms")

        if all_detections:
            confidences = [d['confidence'] for d in all_detections]
            print(f"Confidence range: {min(confidences):.3f} - {max(confidences):.3f}")
            print(f"Average confidence: {np.mean(confidences):.3f}")

        print("="*50)

def main():
    parser = argparse.ArgumentParser(description='Test bullseye detection on video')
    parser.add_argument('--model', default='models/best.pt', help='Path to YOLO model')
    parser.add_argument('--video', type=str, help='Path to video file')
    parser.add_argument('--camera', action='store_true', help='Use camera instead of video file')
    parser.add_argument('--camera-id', type=int, default=0, help='Camera device ID')
    parser.add_argument('--output', type=str, help='Output video path')
    parser.add_argument('--conf', type=float, default=0.5, help='Confidence threshold')
    parser.add_argument('--imgsz', type=int, default=160, help='Model input size')
    parser.add_argument('--no-display', action='store_true', help='Disable video display')
    parser.add_argument('--save', action='store_true', help='Save annotated video')

    args = parser.parse_args()

    # Initialize detector
    detector = BullseyeVideoTester(
        model_path=args.model,
        confidence_threshold=args.conf,
        imgsz=args.imgsz
    )

    if args.camera:
        # Live camera mode
        detector.process_camera(args.camera_id)
    elif args.video:
        # Video file mode
        if not Path(args.video).exists():
            print(f"Error: Video file not found: {args.video}")
            return

        output_path = args.output
        if args.save and not output_path:
            # Auto-generate output filename
            video_path = Path(args.video)
            output_path = video_path.parent / f"{video_path.stem}_detected{video_path.suffix}"

        detector.process_video(
            video_path=args.video,
            output_path=output_path,
            display=not args.no_display,
            save_video=args.save
        )
    else:
        print("Error: Please specify either --video or --camera")
        parser.print_help()

if __name__ == "__main__":
    main()


--- debug\debug_position.py ---
# debug_position.py - NEW FUNCTION
"""
Quick Position Debug Script
--------------------------
This script quickly tests your position data issue while the drone is on the ground.
Run this to see if you can reproduce the position data dropouts.
"""

import time
import logging
from pymavlink import mavutil

def quick_position_test(connection_string="tcp:127.0.0.1:5761", duration=60):
    """Quick test of position data reliability"""

    print("=== QUICK POSITION DEBUG TEST ===")
    print(f"Duration: {duration} seconds")
    print("Testing position data reliability...")
    print("=" * 50)

    try:
        # Connect
        print("Connecting to vehicle...")
        vehicle = mavutil.mavlink_connection(connection_string)
        vehicle.wait_heartbeat()
        print(f"Connected to system {vehicle.target_system}")

        # Request position data multiple ways
        print("Requesting position streams...")

        # Method 1: Modern message interval
        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            200000, 0, 0, 0, 0, 0  # 5 Hz
        )

        # Method 2: Legacy stream request
        vehicle.mav.request_data_stream_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_POSITION, 5, 1
        )

        print("Starting position monitoring...")
        print("Time     | Latitude    | Longitude   | Altitude | Gap   | Status")
        print("-" * 70)

        start_time = time.time()
        last_msg_time = None
        msg_count = 0
        gaps = []

        while time.time() - start_time < duration:
            # Try to get position message
            msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=2.0)

            current_time = time.time()

            if msg:
                msg_count += 1
                lat = msg.lat / 1e7
                lon = msg.lon / 1e7
                alt = msg.relative_alt / 1000.0

                # Calculate gap
                gap = 0
                if last_msg_time:
                    gap = current_time - last_msg_time
                    gaps.append(gap)

                # Status
                status = "OK"
                if gap > 1.0:
                    status = "LONG GAP!"
                elif gap > 0.5:
                    status = "gap"

                timestamp = time.strftime("%H:%M:%S")
                print(f"{timestamp} | {lat:>11.7f} | {lon:>11.7f} | {alt:>8.2f} | {gap:>5.2f} | {status}")

                last_msg_time = current_time

            else:
                # No message received
                gap = current_time - last_msg_time if last_msg_time else 0
                timestamp = time.strftime("%H:%M:%S")
                print(f"{timestamp} | {'NO DATA':>11} | {'NO DATA':>11} | {'NO DATA':>8} | {gap:>5.2f} | TIMEOUT!")

        # Summary
        print("\n" + "=" * 50)
        print("SUMMARY:")
        print(f"Messages received: {msg_count}")
        print(f"Expected messages: ~{duration * 5}")
        print(f"Success rate: {(msg_count / (duration * 5)) * 100:.1f}%")

        if gaps:
            avg_gap = sum(gaps) / len(gaps)
            max_gap = max(gaps)
            print(f"Average gap: {avg_gap:.3f}s")
            print(f"Maximum gap: {max_gap:.3f}s")
            long_gaps = [g for g in gaps if g > 1.0]
            print(f"Gaps > 1s: {len(long_gaps)}")

        vehicle.close()
        return True

    except Exception as e:
        print(f"Error: {str(e)}")
        return False

if __name__ == "__main__":
    import sys
    duration = int(sys.argv[1]) if len(sys.argv) > 1 else 60
    quick_position_test(duration=duration)


--- debug\message_rate_diagnostic.py ---
# message_rate_diagnostic.py - NEW FUNCTION
"""
Message Rate Diagnostic Tool
---------------------------
This script specifically diagnoses why you're getting 3.6 Hz instead of 10 Hz
for position messages. It tests different request methods and rates.
"""

import time
import logging
from pymavlink import mavutil
from collections import defaultdict
import statistics

def test_message_rate_methods(connection_string="tcp:127.0.0.1:5761"):
    """Test different methods of requesting position messages"""

    print("=== MESSAGE RATE DIAGNOSTIC ===")
    print("Testing different message request methods...")
    print("=" * 80)

    try:
        # Connect
        print("Connecting to vehicle...")
        vehicle = mavutil.mavlink_connection(connection_string)
        vehicle.wait_heartbeat()
        print(f"Connected to system {vehicle.target_system}, component {vehicle.target_component}")

        # Get autopilot info
        print("\nRequesting autopilot version...")
        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES, 0,
            1, 0, 0, 0, 0, 0, 0
        )

        # Check what the autopilot reports as capabilities
        version_msg = vehicle.recv_match(type='AUTOPILOT_VERSION', blocking=True, timeout=3)
        if version_msg:
            print(f"Autopilot capabilities: {version_msg.capabilities}")
        else:
            print("No autopilot version received")

        # Test different request rates
        test_rates = [1, 2, 5, 10, 20]

        for requested_rate in test_rates:
            print(f"\n" + "="*50)
            print(f"TESTING REQUESTED RATE: {requested_rate} Hz")
            print("="*50)

            # Clear message buffer
            while vehicle.recv_match(blocking=False):
                pass

            # Method 1: Message interval request
            print(f"Method 1: SET_MESSAGE_INTERVAL for {requested_rate} Hz")
            interval_us = int(1000000 / requested_rate)

            vehicle.mav.command_long_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
                mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
                interval_us, 0, 0, 0, 0, 0
            )

            # Wait for acknowledgment
            ack = vehicle.recv_match(type='COMMAND_ACK', blocking=True, timeout=2)
            if ack and ack.command == mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL:
                ack_result = {
                    0: "ACCEPTED",
                    1: "TEMPORARILY_REJECTED",
                    2: "DENIED",
                    3: "UNSUPPORTED",
                    4: "FAILED"
                }.get(ack.result, f"UNKNOWN({ack.result})")
                print(f"  Command ACK: {ack_result}")
            else:
                print("  No ACK received for message interval command")

            # Method 2: Legacy data stream request
            print(f"Method 2: REQUEST_DATA_STREAM for {requested_rate} Hz")
            vehicle.mav.request_data_stream_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_DATA_STREAM_POSITION,
                requested_rate, 1
            )

            # Measure actual rate for 10 seconds
            print(f"Measuring actual rate for 10 seconds...")

            start_time = time.time()
            message_times = []
            test_duration = 10

            print("Time     | Messages | Current Rate | Avg Rate | Gap")
            print("-" * 50)

            while time.time() - start_time < test_duration:
                msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=1)
                if msg:
                    msg_time = time.time()
                    message_times.append(msg_time)

                    # Calculate current rate (over last 5 messages)
                    if len(message_times) >= 5:
                        recent_times = message_times[-5:]
                        time_span = recent_times[-1] - recent_times[0]
                        current_rate = 4 / time_span if time_span > 0 else 0
                    else:
                        current_rate = 0

                    # Calculate average rate
                    elapsed = msg_time - start_time
                    avg_rate = len(message_times) / elapsed if elapsed > 0 else 0

                    # Calculate gap from last message
                    gap = message_times[-1] - message_times[-2] if len(message_times) > 1 else 0

                    timestamp = time.strftime("%H:%M:%S")
                    print(f"\r{timestamp} | {len(message_times):>8} | {current_rate:>12.2f} | {avg_rate:>8.2f} | {gap:>5.3f}", end="")

                else:
                    print("\nTimeout waiting for message!")
                    break

            # Calculate final statistics
            if len(message_times) >= 2:
                total_time = message_times[-1] - message_times[0]
                actual_rate = (len(message_times) - 1) / total_time

                # Calculate message intervals
                intervals = [message_times[i] - message_times[i-1] for i in range(1, len(message_times))]
                avg_interval = statistics.mean(intervals)
                std_interval = statistics.stdev(intervals) if len(intervals) > 1 else 0
                min_interval = min(intervals)
                max_interval = max(intervals)

                print(f"\n\nRESULTS for {requested_rate} Hz request:")
                print(f"  Requested Rate: {requested_rate:.1f} Hz")
                print(f"  Actual Rate: {actual_rate:.2f} Hz")
                print(f"  Efficiency: {(actual_rate/requested_rate*100):.1f}%")
                print(f"  Messages Received: {len(message_times)}")
                print(f"  Average Interval: {avg_interval:.3f}s (should be {1/requested_rate:.3f}s)")
                print(f"  Interval Std Dev: {std_interval:.3f}s")
                print(f"  Min Interval: {min_interval:.3f}s")
                print(f"  Max Interval: {max_interval:.3f}s")

                # Identify the issue
                if actual_rate < requested_rate * 0.8:
                    print(f"  ❌ ISSUE: Getting {actual_rate:.1f} Hz instead of {requested_rate} Hz")
                    if std_interval > 0.1:
                        print(f"  ❌ ISSUE: High interval variability ({std_interval:.3f}s)")
                    if max_interval > (2 / requested_rate):
                        print(f"  ❌ ISSUE: Large gaps detected (max: {max_interval:.3f}s)")
                else:
                    print(f"  ✅ GOOD: Rate is within acceptable range")
            else:
                print(f"\n❌ FAILED: No messages received at {requested_rate} Hz")

            # Stop the stream before next test
            vehicle.mav.command_long_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
                mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
                0, 0, 0, 0, 0, 0  # 0 = stop
            )

            vehicle.mav.request_data_stream_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_DATA_STREAM_POSITION,
                0, 0  # Stop stream
            )

            time.sleep(1)  # Brief pause between tests

        # Test what rates the autopilot actually supports
        print(f"\n" + "="*80)
        print("AUTOPILOT RATE LIMITS TEST")
        print("="*80)
        print("Testing maximum sustainable rate...")

        # Test very high rate to see what autopilot can actually do
        high_rates = [50, 100, 200]

        for high_rate in high_rates:
            print(f"\nTesting {high_rate} Hz request...")

            # Clear buffer
            while vehicle.recv_match(blocking=False):
                pass

            # Request high rate
            interval_us = int(1000000 / high_rate)
            vehicle.mav.command_long_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
                mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
                interval_us, 0, 0, 0, 0, 0
            )

            # Measure for 5 seconds
            start_time = time.time()
            msg_count = 0

            while time.time() - start_time < 5:
                msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=0.1)
                if msg:
                    msg_count += 1

            actual_rate = msg_count / 5
            print(f"  Requested: {high_rate} Hz, Actual: {actual_rate:.2f} Hz")

            # Stop stream
            vehicle.mav.command_long_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
                mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
                0, 0, 0, 0, 0, 0
            )

        print(f"\n" + "="*80)
        print("DIAGNOSIS COMPLETE")
        print("="*80)

        vehicle.close()
        return True

    except Exception as e:
        print(f"Error during message rate test: {str(e)}")
        return False

if __name__ == "__main__":
    test_message_rate_methods()


--- debug\test_position_tracking.py ---
# test_position_tracking.py - NEW FUNCTION
"""
GPS Position Tracking Diagnostic Test
------------------------------------
This script tests GPS position tracking while the drone is on the ground.
You can move the drone around manually or walk around with it to test
position data reliability and identify when/why position data drops out.
"""

import time
import logging
import math
from pymavlink import mavutil
from datetime import datetime
import json

def setup_logging():
    """Set up logging for the test"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('position_test.log'),
            logging.StreamHandler()
        ]
    )

def connect_to_vehicle(connection_string="tcp:127.0.0.1:5761"):
    """Connect to the vehicle"""
    try:
        logging.info(f"Connecting to vehicle at {connection_string}")
        vehicle = mavutil.mavlink_connection(connection_string)
        vehicle.wait_heartbeat()
        logging.info(f"Connected to vehicle (system: {vehicle.target_system}, component: {vehicle.target_component})")
        return vehicle
    except Exception as e:
        logging.error(f"Failed to connect: {str(e)}")
        return None

def request_position_streams(vehicle, rate_hz=10):
    """Request position data streams at specified rate"""
    try:
        # Request GLOBAL_POSITION_INT messages
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            int(1000000 / rate_hz),  # Interval in microseconds
            0, 0, 0, 0, 0
        )

        # Also request GPS_RAW_INT for GPS health monitoring
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,
            mavutil.mavlink.MAVLINK_MSG_ID_GPS_RAW_INT,
            int(1000000 / rate_hz),
            0, 0, 0, 0, 0
        )

        # Request VFR_HUD for additional data
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,
            mavutil.mavlink.MAVLINK_MSG_ID_VFR_HUD,
            int(1000000 / rate_hz),
            0, 0, 0, 0, 0
        )

        # Legacy method as backup
        vehicle.mav.request_data_stream_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_POSITION,
            rate_hz,
            1
        )

        logging.info(f"Requested position streams at {rate_hz} Hz")
        return True

    except Exception as e:
        logging.error(f"Failed to request position streams: {str(e)}")
        return False

def calculate_distance(lat1, lon1, lat2, lon2):
    """Calculate distance between two GPS coordinates"""
    if lat1 is None or lon1 is None or lat2 is None or lon2 is None:
        return None

    # Haversine formula
    R = 6371000  # Earth radius in meters
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    dlat_rad = math.radians(lat2 - lat1)
    dlon_rad = math.radians(lon2 - lon1)

    a = (math.sin(dlat_rad/2) * math.sin(dlat_rad/2) +
         math.cos(lat1_rad) * math.cos(lat2_rad) *
         math.sin(dlon_rad/2) * math.sin(dlon_rad/2))
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    distance = R * c

    return distance

def calculate_speed(distance, time_diff):
    """Calculate speed from distance and time"""
    if distance is None or time_diff <= 0:
        return None
    return distance / time_diff

def run_position_tracking_test(vehicle, duration=300, rate_hz=10):
    """
    Run comprehensive position tracking test

    Args:
        vehicle: Connected mavlink vehicle
        duration: Test duration in seconds (300 = 5 minutes)
        rate_hz: Requested update rate in Hz
    """

    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("="*80)
        logging.info("STARTING GPS POSITION TRACKING TEST")
        logging.info("="*80)
        logging.info(f"Duration: {duration} seconds ({duration/60:.1f} minutes)")
        logging.info(f"Requested rate: {rate_hz} Hz")
        logging.info("You can now move the drone around to test position tracking")
        logging.info("Press Ctrl+C to stop early")
        logging.info("="*80)

        # Request position streams
        if not request_position_streams(vehicle, rate_hz):
            return False

        # Initialize tracking variables
        start_time = time.time()
        last_position_time = None
        last_lat = None
        last_lon = None
        last_alt = None

        # Statistics
        total_messages = 0
        position_messages = 0
        gps_messages = 0
        max_gap = 0
        gaps_over_1s = 0
        total_distance = 0
        max_speed = 0

        # GPS health tracking
        gps_fix_counts = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}  # Extended GPS fix types
        satellite_counts = []

        # Message timing analysis
        message_gaps = []
        expected_interval = 1.0 / rate_hz

        print("\n" + "="*100)
        print("REAL-TIME POSITION TRACKING")
        print("="*100)
        print("Time     | Latitude    | Longitude   | Altitude | Sats | Fix | Speed  | Gap   | Distance")
        print("-"*100)

        try:
            while time.time() - start_time < duration:
                current_time = time.time()

                # Process all available messages
                message_found = False
                while True:
                    msg = vehicle.recv_match(blocking=False, timeout=0.01)
                    if not msg:
                        break

                    total_messages += 1
                    message_found = True
                    msg_type = msg.get_type()

                    # Process GLOBAL_POSITION_INT messages
                    if msg_type == "GLOBAL_POSITION_INT":
                        position_messages += 1

                        # Extract position data
                        current_lat = msg.lat / 1e7
                        current_lon = msg.lon / 1e7
                        current_alt = msg.relative_alt / 1000.0

                        # Calculate timing gap
                        gap = 0
                        if last_position_time:
                            gap = current_time - last_position_time
                            message_gaps.append(gap)
                            max_gap = max(max_gap, gap)
                            if gap > 1.0:
                                gaps_over_1s += 1

                        # Calculate distance and speed
                        distance = 0
                        speed = 0
                        if last_lat is not None and last_lon is not None:
                            distance = calculate_distance(last_lat, last_lon, current_lat, current_lon)
                            if distance:
                                total_distance += distance
                                if gap > 0:
                                    speed = calculate_speed(distance, gap)
                                    if speed:
                                        max_speed = max(max_speed, speed)

                        # Display current position
                        timestamp = datetime.now().strftime("%H:%M:%S")
                        print(f"{timestamp} | {current_lat:>11.7f} | {current_lon:>11.7f} | {current_alt:>8.2f} | ---- | --- | {speed:>6.2f} | {gap:>5.2f} | {distance:>8.2f}")

                        # Update tracking variables
                        last_position_time = current_time
                        last_lat = current_lat
                        last_lon = current_lon
                        last_alt = current_alt

                    # Process GPS_RAW_INT messages for GPS health
                    elif msg_type == "GPS_RAW_INT":
                        gps_messages += 1

                        fix_type = msg.fix_type
                        satellites = msg.satellites_visible

                        # Track GPS statistics
                        if fix_type in gps_fix_counts:
                            gps_fix_counts[fix_type] += 1
                        satellite_counts.append(satellites)

                        # Update display with GPS info
                        fix_names = {0: "NON", 1: "NOF", 2: "2D ", 3: "3D ", 4: "DGP", 5: "RTK", 6: "FLT"}
                        fix_name = fix_names.get(fix_type, f"{fix_type:3d}")

                        # Overwrite last line with GPS info
                        if position_messages > 0:  # Only if we have position data
                            print(f"\r{timestamp} | {current_lat:>11.7f} | {current_lon:>11.7f} | {current_alt:>8.2f} | {satellites:>4d} | {fix_name} | {speed:>6.2f} | {gap:>5.2f} | {distance:>8.2f}", end="")

                # Check for message timeout
                if not message_found and last_position_time:
                    gap = current_time - last_position_time
                    if gap > 2.0:  # 2 second timeout warning
                        print(f"\n⚠️  WARNING: No position data for {gap:.1f} seconds!", end="")

                # Brief sleep to prevent 100% CPU usage
                time.sleep(0.01)

        except KeyboardInterrupt:
            print(f"\n\nTest stopped by user after {time.time() - start_time:.1f} seconds")

        # Calculate final statistics
        test_duration = time.time() - start_time
        avg_gap = sum(message_gaps) / len(message_gaps) if message_gaps else 0
        actual_rate = position_messages / test_duration if test_duration > 0 else 0
        avg_satellites = sum(satellite_counts) / len(satellite_counts) if satellite_counts else 0

        # Print comprehensive summary
        print("\n" + "="*80)
        print("TEST SUMMARY")
        print("="*80)
        print(f"Test Duration: {test_duration:.1f} seconds")
        print(f"Requested Rate: {rate_hz} Hz")
        print(f"Actual Rate: {actual_rate:.2f} Hz")
        print(f"Rate Efficiency: {(actual_rate/rate_hz*100):.1f}%")
        print()
        print("MESSAGE STATISTICS:")
        print(f"  Total Messages: {total_messages}")
        print(f"  Position Messages: {position_messages}")
        print(f"  GPS Health Messages: {gps_messages}")
        print()
        print("TIMING ANALYSIS:")
        print(f"  Expected Interval: {expected_interval:.3f}s")
        print(f"  Average Gap: {avg_gap:.3f}s")
        print(f"  Maximum Gap: {max_gap:.3f}s")
        print(f"  Gaps > 1 second: {gaps_over_1s}")
        print()
        print("GPS HEALTH:")
        print(f"  Average Satellites: {avg_satellites:.1f}")
        print(f"  GPS Fix Distribution:")
        fix_names = {0: "No GPS", 1: "No Fix", 2: "2D Fix", 3: "3D Fix", 4: "3D DGPS", 5: "RTK Float", 6: "RTK Fixed"}
        for fix_type, count in gps_fix_counts.items():
            if count > 0:  # Only show fix types that occurred
                percentage = (count / gps_messages * 100) if gps_messages > 0 else 0
                print(f"    {fix_names.get(fix_type, f'Fix Type {fix_type}')}: {count} ({percentage:.1f}%)")
        print()
        print("MOVEMENT ANALYSIS:")
        print(f"  Total Distance: {total_distance:.2f} meters")
        print(f"  Maximum Speed: {max_speed:.2f} m/s")
        print(f"  Average Speed: {total_distance/test_duration:.2f} m/s")

        # Identify potential issues
        print("\n" + "="*80)
        print("POTENTIAL ISSUES DETECTED:")
        print("="*80)

        issues_found = False

        if actual_rate < rate_hz * 0.8:
            print(f"❌ LOW MESSAGE RATE: Getting {actual_rate:.1f} Hz instead of {rate_hz} Hz")
            issues_found = True

        if max_gap > 2.0:
            print(f"❌ LARGE MESSAGE GAPS: Maximum gap of {max_gap:.1f} seconds detected")
            issues_found = True

        if gaps_over_1s > 5:
            print(f"❌ FREQUENT GAPS: {gaps_over_1s} gaps over 1 second detected")
            issues_found = True

        if avg_satellites < 8:
            print(f"⚠️  LOW SATELLITE COUNT: Average of {avg_satellites:.1f} satellites")
            issues_found = True

        # Check for good GPS fixes (3D or better)
        good_gps_fixes = gps_fix_counts.get(3, 0) + gps_fix_counts.get(4, 0) + gps_fix_counts.get(5, 0) + gps_fix_counts.get(6, 0)
        good_gps_percentage = (good_gps_fixes / gps_messages * 100) if gps_messages > 0 else 0
        if good_gps_percentage < 95:
            print(f"⚠️  POOR GPS FIX: Only {good_gps_percentage:.1f}% good GPS fixes (3D/DGPS/RTK)")
            issues_found = True
        else:
            print(f"✅ EXCELLENT GPS: {good_gps_percentage:.1f}% good GPS fixes")

        # Check message rate efficiency
        rate_efficiency = (actual_rate / rate_hz * 100) if rate_hz > 0 else 0
        if rate_efficiency < 80:
            print(f"❌ LOW MESSAGE RATE EFFICIENCY: {rate_efficiency:.1f}% of requested rate")
            print(f"   This suggests autopilot message throttling or connection issues")
            issues_found = True

        if not issues_found:
            print("✅ No major issues detected!")

        # Save detailed log
        log_data = {
            'test_duration': test_duration,
            'requested_rate': rate_hz,
            'actual_rate': actual_rate,
            'total_messages': total_messages,
            'position_messages': position_messages,
            'message_gaps': message_gaps,
            'gps_fix_counts': gps_fix_counts,
            'satellite_counts': satellite_counts,
            'total_distance': total_distance,
            'max_speed': max_speed
        }

        with open('position_test_results.json', 'w') as f:
            json.dump(log_data, f, indent=2)

        print(f"\nDetailed results saved to position_test_results.json")
        print("="*80)

        return True

    except Exception as e:
        logging.error(f"Error during position tracking test: {str(e)}")
        return False

def main():
    """Main function to run the position tracking test"""
    setup_logging()

    import argparse
    parser = argparse.ArgumentParser(description="GPS Position Tracking Diagnostic Test")
    parser.add_argument("--connection", default="tcp:127.0.0.1:5761", help="Connection string")
    parser.add_argument("--duration", type=int, default=300, help="Test duration in seconds")
    parser.add_argument("--rate", type=int, default=10, help="Requested update rate in Hz")

    args = parser.parse_args()

    # Connect to vehicle
    vehicle = connect_to_vehicle(args.connection)
    if not vehicle:
        return 1

    try:
        # Run the test
        success = run_position_tracking_test(vehicle, args.duration, args.rate)
        return 0 if success else 1

    finally:
        if vehicle:
            vehicle.close()

if __name__ == "__main__":
    exit(main())


--- detection\bullseye_detector.py ---
# detection/bullseye_detector.py - UPDATED TO USE YOLO MODEL
"""
Bullseye Detection Module using YOLO Model
------------------------------------------
Updated to use trained YOLO model instead of OpenCV pattern matching.
Optimized for drone competition use with Jetson Orin Nano.
"""

import cv2
import numpy as np
import logging
import time
import os
from typing import List, Tuple, Optional, Union
from pathlib import Path

try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO_AVAILABLE = False
    logging.warning("YOLO not available - install ultralytics: pip install ultralytics")

class BullseyeDetector:
    """YOLO-based bullseye detector for drone use"""

    def __init__(self, model_path="models/best.pt", confidence_threshold=0.5, imgsz=160):
        """
        Initialize the bullseye detector with YOLO model.

        Args:
            model_path: Path to the YOLO model file (best.pt or best.engine)
            confidence_threshold: Minimum confidence for detections
            imgsz: Input image size for the model
        """
        if not YOLO_AVAILABLE:
            raise ImportError("YOLO not available. Install with: pip install ultralytics")

        self.model_path = model_path
        self.conf_threshold = confidence_threshold
        self.imgsz = imgsz

        # Try to load the model
        if not os.path.exists(model_path):
            logging.error(f"Model file not found: {model_path}")
            # Try common locations
            alt_paths = [
                "best.pt",
                "models/best.pt",
                "best.engine",
                "models/best.engine"
            ]
            for alt_path in alt_paths:
                if os.path.exists(alt_path):
                    self.model_path = alt_path
                    logging.info(f"Found model at: {alt_path}")
                    break
            else:
                raise FileNotFoundError(f"Could not find model file. Tried: {model_path}, {alt_paths}")

        logging.info(f"Loading YOLO model: {self.model_path}")
        self.model = YOLO(self.model_path)

        # Performance tracking
        self.frame_count = 0
        self.total_inference_time = 0
        self.detections_count = 0

    def detect_bullseyes_in_frame(self, frame):
        """
        Detect bullseyes in a single frame using YOLO model.

        Args:
            frame: Input BGR image

        Returns:
            Tuple of (bullseyes, debug_image)
            bullseyes: List of (center_x, center_y, bbox_info, confidence)
            debug_image: Annotated image showing detections
        """
        if frame is None:
            return [], frame

        try:
            start_time = time.time()

            # Run YOLO inference
            results = self.model.predict(
                frame,
                imgsz=self.imgsz,
                conf=self.conf_threshold,
                verbose=False
            )

            inference_time = time.time() - start_time
            self.total_inference_time += inference_time
            self.frame_count += 1

            # Process results
            bullseyes = []
            debug_image = frame.copy()

            for result in results:
                if result.boxes is not None:
                    for box in result.boxes:
                        # Extract box coordinates and confidence
                        x1, y1, x2, y2 = map(int, box.xyxy[0])
                        confidence = float(box.conf[0])

                        # Calculate center
                        center_x = (x1 + x2) // 2
                        center_y = (y1 + y2) // 2

                        # Create bbox info dictionary
                        bbox_info = {
                            'bbox': (x1, y1, x2, y2),
                            'width': x2 - x1,
                            'height': y2 - y1,
                            'area': (x2 - x1) * (y2 - y1)
                        }

                        # Add to bullseyes list (format compatible with old system)
                        bullseyes.append((center_x, center_y, bbox_info, confidence))
                        self.detections_count += 1

                        # Draw on debug image
                        self._draw_detection(debug_image, x1, y1, x2, y2, center_x, center_y, confidence)

            # Add frame info to debug image
            self._add_frame_info(debug_image, len(bullseyes), inference_time)

            return bullseyes, debug_image

        except Exception as e:
            logging.error(f"Error in YOLO bullseye detection: {str(e)}")
            return [], frame

    def _draw_detection(self, image, x1, y1, x2, y2, center_x, center_y, confidence):
        """Draw detection on image"""
        # Draw bounding box
        cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

        # Draw center point
        cv2.circle(image, (center_x, center_y), 5, (255, 0, 0), -1)

        # Draw crosshair at center
        cv2.line(image, (center_x - 10, center_y), (center_x + 10, center_y), (255, 0, 0), 2)
        cv2.line(image, (center_x, center_y - 10), (center_x, center_y + 10), (255, 0, 0), 2)

        # Add confidence label
        label = f"Bullseye: {confidence:.3f}"
        label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)[0]
        cv2.rectangle(image, (x1, y1 - label_size[1] - 10),
                     (x1 + label_size[0], y1), (0, 255, 0), -1)
        cv2.putText(image, label, (x1, y1 - 5),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)

    def _add_frame_info(self, image, num_detections, inference_time):
        """Add frame information overlay"""
        # Calculate FPS
        fps = 1.0 / inference_time if inference_time > 0 else 0

        # Add frame info
        info_text = f"FPS: {fps:.1f} | Detections: {num_detections} | Frame: {self.frame_count}"
        cv2.putText(image, info_text, (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        cv2.putText(image, info_text, (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 1)

        # Add crosshair at frame center for drone alignment reference
        h, w = image.shape[:2]
        cv2.line(image, (w//2 - 20, h//2), (w//2 + 20, h//2), (0, 0, 255), 2)
        cv2.line(image, (w//2, h//2 - 20), (w//2, h//2 + 20), (0, 0, 255), 2)
        cv2.circle(image, (w//2, h//2), 3, (0, 0, 255), -1)

    def get_performance_stats(self):
        """Get performance statistics"""
        if self.frame_count == 0:
            return {}

        avg_fps = self.frame_count / self.total_inference_time if self.total_inference_time > 0 else 0
        avg_inference_ms = (self.total_inference_time / self.frame_count) * 1000

        return {
            'total_frames': self.frame_count,
            'total_detections': self.detections_count,
            'avg_detections_per_frame': self.detections_count / self.frame_count,
            'avg_fps': avg_fps,
            'avg_inference_ms': avg_inference_ms
        }

def create_enhanced_detection_display(original_frame, bullseyes, debug_image):
    """
    Create enhanced display with big indicators for detections.
    Updated to work with YOLO detection format.
    """
    enhanced = debug_image.copy()
    height, width = enhanced.shape[:2]

    # Add big detection indicators
    if len(bullseyes) > 0:
        # Green background overlay for success
        overlay = enhanced.copy()
        cv2.rectangle(overlay, (0, 0), (width, 80), (0, 150, 0), -1)
        enhanced = cv2.addWeighted(enhanced, 0.7, overlay, 0.3, 0)

        # Big success text
        cv2.putText(enhanced, f"🎯 BULLSEYE DETECTED! ({len(bullseyes)} found)",
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)
        cv2.putText(enhanced, f"🎯 BULLSEYE DETECTED! ({len(bullseyes)} found)",
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (0, 255, 0), 2)

        # Draw big circles around detections
        for i, (center_x, center_y, bbox_info, confidence) in enumerate(bullseyes):
            # Big outer circle
            cv2.circle(enhanced, (center_x, center_y), 80, (0, 255, 0), 5)
            # Confidence text
            conf_text = f"Confidence: {confidence:.1%}"
            cv2.putText(enhanced, conf_text, (center_x - 60, center_y + 100),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
    else:
        # Red background overlay for no detection
        overlay = enhanced.copy()
        cv2.rectangle(overlay, (0, 0), (width, 60), (0, 0, 150), -1)
        enhanced = cv2.addWeighted(enhanced, 0.8, overlay, 0.2, 0)

        # No detection text
        cv2.putText(enhanced, "🔍 NO BULLSEYES DETECTED",
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 3)
        cv2.putText(enhanced, "🔍 NO BULLSEYES DETECTED",
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 2)

    return enhanced

def test_bullseye_detection(source: Union[str, int] = 0,
                          display: bool = True,
                          save_results: bool = True,
                          duration: float = 0,
                          video_delay: float = 0.1,
                          model_path: str = "models/best.pt",
                          confidence: float = 0.5,
                          imgsz: int = 160) -> bool:
    """
    Test YOLO-based bullseye detection on camera feed, video file, or image.

    Args:
        source: Camera ID (int), video file path, or image file path
        display: Whether to display the detection results
        save_results: Whether to save detection results
        duration: Duration for camera/video (0 = until 'q' pressed)
        video_delay: Delay between frames for video/camera (seconds)
        model_path: Path to YOLO model file
        confidence: Confidence threshold for detections
        imgsz: Model input image size

    Returns:
        True if test completed successfully
    """
    try:
        logging.info(f"Starting YOLO bullseye detection test with source: {source}")

        detector = BullseyeDetector(
            model_path=model_path,
            confidence_threshold=confidence,
            imgsz=imgsz
        )

        # Determine source type
        if isinstance(source, int):
            # Camera input
            cap = cv2.VideoCapture(source)
            if not cap.isOpened():
                logging.error(f"Failed to open camera {source}")
                return False

            # Set camera properties for drone use
            cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            cap.set(cv2.CAP_PROP_FPS, 30)
            source_type = "camera"

        elif isinstance(source, str):
            if source.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp')):
                # Image file
                image = cv2.imread(source)
                if image is None:
                    logging.error(f"Failed to load image: {source}")
                    return False
                source_type = "image"
            else:
                # Video file
                cap = cv2.VideoCapture(source)
                if not cap.isOpened():
                    logging.error(f"Failed to open video: {source}")
                    return False
                source_type = "video"
        else:
            logging.error("Invalid source type")
            return False

        # Process single image
        if source_type == "image":
            bullseyes, debug_image = detector.detect_bullseyes_in_frame(image)

            # Create enhanced display image
            enhanced_image = create_enhanced_detection_display(image, bullseyes, debug_image)

            logging.info(f"Detected {len(bullseyes)} bullseyes in image")
            for i, (x, y, bbox_info, confidence) in enumerate(bullseyes):
                logging.info(f"Bullseye {i+1}: Center ({x}, {y}), Confidence: {confidence:.3f}")

            if display:
                cv2.imshow("YOLO Bullseye Detection Results", enhanced_image)
                print("\n" + "="*60)
                print("📸 YOLO IMAGE DETECTION RESULTS")
                print("="*60)
                if len(bullseyes) > 0:
                    print(f"🎯 BULLSEYES FOUND: {len(bullseyes)}")
                    for i, (x, y, bbox_info, confidence) in enumerate(bullseyes):
                        print(f"   Bullseye {i+1}: Position ({x}, {y}), Confidence: {confidence:.1%}")
                else:
                    print("❌ NO BULLSEYES DETECTED")
                print("="*60)
                print("Press any key to close...")
                cv2.waitKey(0)
                cv2.destroyAllWindows()

            if save_results:
                timestamp = time.strftime("%Y%m%d_%H%M%S")
                filename = f"yolo_bullseye_detection_{timestamp}.jpg"
                cv2.imwrite(filename, enhanced_image)
                logging.info(f"Results saved to: {filename}")

            return True

        # Process video or camera feed
        else:
            total_frames = 0
            detection_frames = 0
            start_time = time.time()

            if source_type == "video":
                total_video_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                video_fps = cap.get(cv2.CAP_PROP_FPS)
                logging.info(f"Video: {total_video_frames} frames @ {video_fps} FPS")

            logging.info(f"Processing {source_type}. Press 'q' to quit, 's' to save frame")
            print("\n" + "="*80)
            print(f"🎥 {source_type.upper()} YOLO BULLSEYE DETECTION")
            print("="*80)
            print("Controls: 'q' = quit, 's' = save frame, 'p' = pause")
            print("="*80)

            while True:
                ret, frame = cap.read()

                if not ret:
                    if source_type == "camera":
                        logging.error("Failed to capture frame")
                        break
                    else:
                        logging.info("End of video reached")
                        break

                total_frames += 1

                # Detect bullseyes
                bullseyes, debug_image = detector.detect_bullseyes_in_frame(frame)

                # Create enhanced display
                enhanced_image = create_enhanced_detection_display(frame, bullseyes, debug_image)

                # Track detections
                if bullseyes:
                    detection_frames += 1
                    print(f"🎯 Frame {total_frames}: {len(bullseyes)} bullseye(s) detected!")
                    for i, (x, y, bbox_info, confidence) in enumerate(bullseyes):
                        print(f"   → Bullseye {i+1} at ({x}, {y}), confidence: {confidence:.3f}")
                elif total_frames % 30 == 0:  # Log every 30 frames when no detection
                    print(f"🔍 Frame {total_frames}: Searching for bullseyes...")

                # Display results
                if display:
                    cv2.imshow("YOLO Bullseye Detection", enhanced_image)

                    key = cv2.waitKey(int(video_delay * 1000)) & 0xFF
                    if key == ord('q'):
                        break
                    elif key == ord('s') and save_results:
                        timestamp = time.strftime("%Y%m%d_%H%M%S")
                        filename = f"yolo_bullseye_frame_{total_frames}_{timestamp}.jpg"
                        cv2.imwrite(filename, enhanced_image)
                        logging.info(f"Frame saved: {filename}")
                    elif key == ord('p'):  # Pause
                        cv2.waitKey(0)
                else:
                    time.sleep(video_delay)

                # Check duration for camera
                if source_type == "camera" and duration > 0:
                    if time.time() - start_time >= duration:
                        break

                # Progress for video
                if source_type == "video" and total_frames % 30 == 0:
                    progress = (total_frames / total_video_frames) * 100
                    print(f"Progress: {progress:.1f}% ({total_frames}/{total_video_frames})")

            # Cleanup
            cap.release()
            if display:
                cv2.destroyAllWindows()

            # Final summary
            total_time = time.time() - start_time
            detection_rate = (detection_frames / total_frames * 100) if total_frames > 0 else 0
            stats = detector.get_performance_stats()

            print("\n" + "="*80)
            print("📊 YOLO DETECTION SUMMARY")
            print("="*80)
            print(f"Total frames processed: {total_frames}")
            print(f"Frames with bullseyes: {detection_frames}")
            print(f"Detection rate: {detection_rate:.1f}%")
            print(f"Processing time: {total_time:.1f}s")
            print(f"Average FPS: {stats.get('avg_fps', 0):.1f}")
            print(f"Average inference time: {stats.get('avg_inference_ms', 0):.1f}ms")

            if detection_frames > 0:
                print(f"🎯 SUCCESS: Bullseyes detected in {detection_frames} frames!")
            else:
                print("❌ NO BULLSEYES DETECTED in any frame")
            print("="*80)

            return True

    except Exception as e:
        logging.error(f"Error during YOLO bullseye detection test: {str(e)}")
        return False

def create_bullseye_detector(model_path="models/best.pt", confidence=0.5, imgsz=160):
    """
    Factory function to create a YOLO bullseye detector.

    Returns:
        BullseyeDetector instance
    """
    return BullseyeDetector(model_path, confidence, imgsz)


--- detection\camera.py ---
"""
Camera Module
------------
Functions for managing camera operations, including setup and testing.
"""

import cv2
import time
import logging
import os
import numpy as np

def initialize_camera(camera_id=0, resolution=(640, 480)):
    """
    Initialize the camera.

    Args:
        camera_id: Camera ID (default: 0 for primary camera)
        resolution: Tuple of (width, height) for desired resolution

    Returns:
        Initialized camera object or None if initialization failed
    """
    try:
        cap = cv2.VideoCapture(camera_id)

        # Set resolution
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, resolution[0])
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, resolution[1])

        # Check if camera opened successfully
        if not cap.isOpened():
            logging.error(f"Failed to open camera {camera_id}")
            return None

        # Read a test frame to confirm camera is working
        ret, _ = cap.read()
        if not ret:
            logging.error(f"Failed to read from camera {camera_id}")
            cap.release()
            return None

        logging.info(f"Camera {camera_id} initialized at resolution {resolution}")
        return cap
    except Exception as e:
        logging.error(f"Error initializing camera: {str(e)}")
        return None

def capture_frame(cap):
    """
    Capture a single frame from the camera.

    Args:
        cap: The initialized camera object

    Returns:
        Captured frame or None if capture failed
    """
    if not cap or not cap.isOpened():
        logging.error("Invalid camera object")
        return None

    try:
        ret, frame = cap.read()
        if not ret:
            logging.error("Failed to capture frame")
            return None

        return frame
    except Exception as e:
        logging.error(f"Error capturing frame: {str(e)}")
        return None

def save_frame(frame, output_dir="debug_frames", filename=None):
    """
    Save a frame to disk.

    Args:
        frame: The frame to save
        output_dir: Directory to save the frame
        filename: Filename (if None, use timestamp)

    Returns:
        Path to saved file or None if save failed
    """
    if frame is None:
        logging.error("Cannot save None frame")
        return None

    try:
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Generate filename based on timestamp if not provided
        if filename is None:
            filename = f"frame_{time.strftime('%Y%m%d_%H%M%S')}.jpg"

        # Full path to save the frame
        file_path = os.path.join(output_dir, filename)

        # Save the frame
        cv2.imwrite(file_path, frame)
        logging.info(f"Frame saved to {file_path}")

        return file_path
    except Exception as e:
        logging.error(f"Error saving frame: {str(e)}")
        return None

def test_camera_feed(camera_id=0, duration=10, show_preview=True):
    """
    Test the camera by capturing frames for a specified duration.

    Args:
        camera_id: Camera ID
        duration: Test duration in seconds
        show_preview: Whether to show preview window

    Returns:
        True if test was successful, False otherwise
    """
    try:
        cap = initialize_camera(camera_id)
        if not cap:
            return False

        start_time = time.time()
        frame_count = 0

        logging.info(f"Starting camera test for {duration} seconds")

        # Create debug directory if showing preview
        debug_dir = "debug_frames"
        if not os.path.exists(debug_dir):
            os.makedirs(debug_dir)

        while time.time() - start_time < duration:
            frame = capture_frame(cap)
            if frame is None:
                break

            frame_count += 1

            # Add frame counter and timestamp
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            cv2.putText(frame, f"Frame: {frame_count} Time: {timestamp}",
                      (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

            # Display the frame if preview is enabled
            if show_preview:
                cv2.imshow('Camera Test', frame)

                # Break the loop if 'q' is pressed
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

            # Save every 30th frame
            if frame_count % 30 == 0:
                save_frame(frame, debug_dir, f"test_{frame_count}.jpg")

        # Calculate FPS
        elapsed_time = time.time() - start_time
        fps = frame_count / elapsed_time if elapsed_time > 0 else 0

        # Clean up
        cap.release()
        if show_preview:
            cv2.destroyAllWindows()

        logging.info(f"Camera test completed. Captured {frame_count} frames in {elapsed_time:.1f} seconds ({fps:.1f} FPS)")
        return frame_count > 0
    except Exception as e:
        logging.error(f"Error during camera test: {str(e)}")
        return False

def close_camera(cap):
    """
    Safely release the camera resource.

    Args:
        cap: The camera object to close
    """
    if cap and cap.isOpened():
        try:
            cap.release()
            logging.info("Camera released")
        except Exception as e:
            logging.error(f"Error releasing camera: {str(e)}")

def adjust_camera_settings(cap, brightness=None, contrast=None, saturation=None,
                         exposure=None, auto_exposure=None):
    """
    Adjust camera settings like brightness, contrast, etc.

    Args:
        cap: The initialized camera object
        brightness: Brightness value (typically 0-100)
        contrast: Contrast value (typically 0-100)
        saturation: Saturation value (typically 0-100)
        exposure: Exposure value
        auto_exposure: Auto exposure mode (0: manual, 1: auto)

    Returns:
        True if settings were adjusted successfully, False otherwise
    """
    if not cap or not cap.isOpened():
        logging.error("Invalid camera object")
        return False

    try:
        # Set brightness if specified
        if brightness is not None:
            cap.set(cv2.CAP_PROP_BRIGHTNESS, brightness)
            logging.info(f"Camera brightness set to {brightness}")

        # Set contrast if specified
        if contrast is not None:
            cap.set(cv2.CAP_PROP_CONTRAST, contrast)
            logging.info(f"Camera contrast set to {contrast}")

        # Set saturation if specified
        if saturation is not None:
            cap.set(cv2.CAP_PROP_SATURATION, saturation)
            logging.info(f"Camera saturation set to {saturation}")

        # Set auto exposure mode if specified
        if auto_exposure is not None:
            cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, auto_exposure)
            logging.info(f"Camera auto exposure set to {auto_exposure}")

        # Set exposure if specified and auto exposure is off
        if exposure is not None and (auto_exposure is None or auto_exposure == 0):
            cap.set(cv2.CAP_PROP_EXPOSURE, exposure)
            logging.info(f"Camera exposure set to {exposure}")

        return True
    except Exception as e:
        logging.error(f"Error adjusting camera settings: {str(e)}")
        return False

def get_camera_properties(cap):
    """
    Get current camera properties.

    Args:
        cap: The initialized camera object

    Returns:
        Dictionary of camera properties or None if failed
    """
    if not cap or not cap.isOpened():
        logging.error("Invalid camera object")
        return None

    try:
        properties = {
            "width": cap.get(cv2.CAP_PROP_FRAME_WIDTH),
            "height": cap.get(cv2.CAP_PROP_FRAME_HEIGHT),
            "fps": cap.get(cv2.CAP_PROP_FPS),
            "brightness": cap.get(cv2.CAP_PROP_BRIGHTNESS),
            "contrast": cap.get(cv2.CAP_PROP_CONTRAST),
            "saturation": cap.get(cv2.CAP_PROP_SATURATION),
            "exposure": cap.get(cv2.CAP_PROP_EXPOSURE),
            "auto_exposure": cap.get(cv2.CAP_PROP_AUTO_EXPOSURE)
        }

        logging.info("Retrieved camera properties")
        return properties
    except Exception as e:
        logging.error(f"Error getting camera properties: {str(e)}")
        return None

def list_available_cameras(max_cameras=10):
    """
    List available cameras by trying to open each one.

    Args:
        max_cameras: Maximum number of cameras to check

    Returns:
        List of available camera IDs
    """
    available_cameras = []

    for i in range(max_cameras):
        try:
            cap = cv2.VideoCapture(i)
            if cap.isOpened():
                ret, _ = cap.read()
                if ret:
                    available_cameras.append(i)
                cap.release()
        except:
            pass

    if available_cameras:
        logging.info(f"Found {len(available_cameras)} available cameras: {available_cameras}")
    else:
        logging.warning("No available cameras found")

    return available_cameras


--- detection\gcp.py ---
"""
Ground Control Point (GCP) Detection Module
----------------------------------------
Functions for detecting ground control points like squares, triangles,
and X-patterns for drone navigation and landing.
"""

import cv2
import numpy as np
import math
import logging
import os
import time

def detect_squares(frame, min_area=100, max_area=10000, aspect_ratio_range=(0.8, 1.2)):
    """
    Detect squares in the frame.

    Args:
        frame: Input image frame
        min_area: Minimum contour area to consider
        max_area: Maximum contour area to consider
        aspect_ratio_range: Tuple of (min, max) aspect ratio for square detection

    Returns:
        List of detected squares, each as (x, y, w, h, contour)
    """
    try:
        # Convert to grayscale
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Apply blur to reduce noise
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)

        # Find edges using Canny edge detector
        edges = cv2.Canny(blurred, 50, 150)

        # Find contours
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # List to store detected squares
        squares = []

        # Loop through all contours
        for contour in contours:
            # Filter by area
            area = cv2.contourArea(contour)
            if area < min_area or area > max_area:
                continue

            # Approximate the contour shape
            perimeter = cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)

            # Check if it has 4 vertices (potential square)
            if len(approx) == 4:
                # Get bounding rectangle
                x, y, w, h = cv2.boundingRect(approx)

                # Check aspect ratio for squareness
                aspect_ratio = float(w) / h
                if aspect_ratio_range[0] <= aspect_ratio <= aspect_ratio_range[1]:
                    squares.append((x, y, w, h, approx))

        return squares
    except Exception as e:
        logging.error(f"Error detecting squares: {str(e)}")
        return []

def detect_triangles(frame, min_area=100, max_area=10000, tolerance=0.15):
    """
    Detect triangles in the frame.

    Args:
        frame: Input image frame
        min_area: Minimum contour area to consider
        max_area: Maximum contour area to consider
        tolerance: Tolerance for side length similarity in equilateral triangles

    Returns:
        List of detected triangles, each as (x, y, w, h, contour)
    """
    try:
        # Convert to grayscale
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Apply blur to reduce noise
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)

        # Find edges using Canny edge detector
        edges = cv2.Canny(blurred, 50, 150)

        # Find contours
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # List to store detected triangles
        triangles = []

        # Loop through all contours
        for contour in contours:
            # Filter by area
            area = cv2.contourArea(contour)
            if area < min_area or area > max_area:
                continue

            # Approximate the contour shape
            perimeter = cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)

            # Check if it has 3 vertices (triangle)
            if len(approx) == 3:
                # Calculate side lengths
                side1 = np.linalg.norm(approx[0][0] - approx[1][0])
                side2 = np.linalg.norm(approx[1][0] - approx[2][0])
                side3 = np.linalg.norm(approx[2][0] - approx[0][0])

                # Calculate average side length
                avg_side = (side1 + side2 + side3) / 3

                # Check if it's approximately equilateral
                if (abs(side1 - avg_side) / avg_side < tolerance and
                    abs(side2 - avg_side) / avg_side < tolerance and
                    abs(side3 - avg_side) / avg_side < tolerance):

                    # Get bounding rectangle
                    x, y, w, h = cv2.boundingRect(approx)
                    triangles.append((x, y, w, h, approx))

        return triangles
    except Exception as e:
        logging.error(f"Error detecting triangles: {str(e)}")
        return []

def detect_x_pattern(frame, min_area=500, max_area=100000, diagonal_angle_tolerance=15):
    """
    Detect X-patterns in the frame (squares with diagonal lines).

    Args:
        frame: Input image frame
        min_area: Minimum contour area to consider
        max_area: Maximum contour area to consider
        diagonal_angle_tolerance: Tolerance for diagonal angles (45±tolerance)

    Returns:
        List of detected X-patterns, each as (x, y, w, h, confidence)
    """
    try:
        # First, detect potential squares
        squares = detect_squares(frame, min_area, max_area)

        # Process each square to check for X-pattern
        x_patterns = []

        for x, y, w, h, approx in squares:
            # Create a mask for this square
            mask = np.zeros(frame.shape[:2], dtype=np.uint8)
            cv2.drawContours(mask, [approx], 0, 255, -1)

            # Get the ROI (Region of Interest)
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            roi = cv2.bitwise_and(gray, gray, mask=mask)

            # Skip if ROI is empty
            if roi[mask > 0].size == 0:
                continue

            # Apply edge detection to the ROI
            roi_edges = cv2.Canny(roi, 30, 120)

            # Look for diagonal lines using Hough transform
            lines = cv2.HoughLinesP(
                roi_edges, 1, np.pi/180,
                threshold=15,
                minLineLength=20,
                maxLineGap=20
            )

            # Count diagonal lines
            diagonal_lines = []

            if lines is not None:
                for line in lines:
                    x1, y1, x2, y2 = line[0]

                    # Calculate line angle
                    angle = math.degrees(math.atan2(y2 - y1, x2 - x1)) % 180

                    # Check if line is close to diagonal angles (45 or 135 degrees)
                    if ((45 - diagonal_angle_tolerance <= angle <= 45 + diagonal_angle_tolerance) or
                        (135 - diagonal_angle_tolerance <= angle <= 135 + diagonal_angle_tolerance)):
                        diagonal_lines.append((x1, y1, x2, y2, angle))

            # Check quadrant intensity differences as an alternative method
            h_half, w_half = h // 2, w // 2
            quadrant_pattern_detected = False

            if h_half > 0 and w_half > 0:
                # Define quadrant regions
                q1 = roi[y:y+h_half, x:x+w_half]
                q2 = roi[y:y+h_half, x+w_half:x+w]
                q3 = roi[y+h_half:y+h, x:x+w_half]
                q4 = roi[y+h_half:y+h, x+w_half:x+w]

                # Calculate mean intensity for non-zero pixels in each quadrant
                q1_intensity = np.mean(q1[q1 > 0]) if np.any(q1 > 0) else 0
                q2_intensity = np.mean(q2[q2 > 0]) if np.any(q2 > 0) else 0
                q3_intensity = np.mean(q3[q3 > 0]) if np.any(q3 > 0) else 0
                q4_intensity = np.mean(q4[q4 > 0]) if np.any(q4 > 0) else 0

                # Calculate intensity differences
                diagonal1_diff = abs(q1_intensity - q4_intensity)
                diagonal2_diff = abs(q2_intensity - q3_intensity)
                cross_diff = abs((q1_intensity + q4_intensity) / 2 - (q2_intensity + q3_intensity) / 2)

                # If diagonals have similar intensities within each diagonal but
                # different between diagonals, it's likely an X pattern
                quadrant_pattern_detected = (
                    diagonal1_diff < 10 and
                    diagonal2_diff < 10 and
                    cross_diff > 20
                )

            # Check if this is an X-pattern based on diagonal lines and quadrant analysis
            has_enough_diagonals = len(diagonal_lines) >= 2

            if has_enough_diagonals or quadrant_pattern_detected:
                # Calculate confidence score
                confidence = (len(diagonal_lines) * 0.3) + (1 if quadrant_pattern_detected else 0)
                x_patterns.append((x, y, w, h, confidence))

        return x_patterns
    except Exception as e:
        logging.error(f"Error detecting X-patterns: {str(e)}")
        return []

def detect_triangles_in_squares(frame, min_triangles=4):
    """
    Detect squares containing multiple triangles.

    Args:
        frame: Input image frame
        min_triangles: Minimum number of triangles required inside a square

    Returns:
        List of detected patterns, each as (x, y, w, h, num_triangles)
    """
    try:
        # Detect triangles and squares
        triangles = detect_triangles(frame)
        squares = detect_squares(frame)

        # Check which squares contain multiple triangles
        patterns = []

        for sx, sy, sw, sh, s_approx in squares:
            # Count triangles inside this square
            triangles_inside = 0

            for tx, ty, tw, th, t_approx in triangles:
                # Check if triangle center is inside square
                t_center_x = tx + tw/2
                t_center_y = ty + th/2

                if (sx <= t_center_x <= sx + sw and
                    sy <= t_center_y <= sy + sh):
                    triangles_inside += 1

            # If enough triangles are inside the square
            if triangles_inside >= min_triangles:
                patterns.append((sx, sy, sw, sh, triangles_inside))

        return patterns
    except Exception as e:
        logging.error(f"Error detecting triangles in squares: {str(e)}")
        return []

def detect_gcp_markers(frame, save_debug=False, debug_dir="debug_frames"):
    """
    Detect all types of GCP markers in a frame.

    Args:
        frame: Input image frame
        save_debug: Whether to save debug frames to disk
        debug_dir: Directory to save debug frames

    Returns:
        Dictionary of detected markers by type
    """
    try:
        # Create copy for visualization
        display_frame = frame.copy()

        # Detect different types of markers
        squares = detect_squares(frame)
        triangles = detect_triangles(frame)
        x_patterns = detect_x_pattern(frame)
        tri_in_squares = detect_triangles_in_squares(frame)

        # Draw detections on the display frame
        for x, y, w, h, _ in squares:
            cv2.rectangle(display_frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            cv2.putText(display_frame, "Square", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

        for x, y, w, h, _ in triangles:
            cv2.rectangle(display_frame, (x, y), (x + w, y + h), (255, 0, 0), 2)
            cv2.putText(display_frame, "Triangle", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

        for x, y, w, h, conf in x_patterns:
            cv2.rectangle(display_frame, (x, y), (x + w, y + h), (0, 0, 255), 2)
            cv2.putText(display_frame, f"X-Pattern ({conf:.1f})", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)

        for x, y, w, h, count in tri_in_squares:
            cv2.rectangle(display_frame, (x, y), (x + w, y + h), (255, 0, 255), 3)
            cv2.putText(display_frame, f"{count} triangles", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 2)

        # Save debug frame if requested
        if save_debug:
            if not os.path.exists(debug_dir):
                os.makedirs(debug_dir)

            timestamp = time.strftime("%Y%m%d_%H%M%S")
            cv2.imwrite(f"{debug_dir}/gcp_detection_{timestamp}.jpg", display_frame)

        # Return all detections
        return {
            'display_frame': display_frame,
            'squares': squares,
            'triangles': triangles,
            'x_patterns': x_patterns,
            'tri_in_squares': tri_in_squares
        }
    except Exception as e:
        logging.error(f"Error detecting GCP markers: {str(e)}")
        return {
            'display_frame': frame,
            'squares': [],
            'triangles': [],
            'x_patterns': [],
            'tri_in_squares': []
        }

def run_gcp_detection(camera_id=0, duration=30, save_detected=True):
    """
    Run continuous GCP detection on a camera feed.

    Args:
        camera_id: Camera ID to use
        duration: Duration in seconds (0 for indefinite)
        save_detected: Whether to save frames with detections

    Returns:
        True if completed successfully, False otherwise
    """
    try:
        # Initialize camera
        cap = cv2.VideoCapture(camera_id)
        if not cap.isOpened():
            logging.error(f"Failed to open camera {camera_id}")
            return False

        # Create debug directory
        debug_dir = "debug_frames"
        if not os.path.exists(debug_dir):
            os.makedirs(debug_dir)

        # Start detection loop
        start_time = time.time()
        frame_count = 0
        detection_count = 0

        logging.info(f"Starting GCP detection for {duration} seconds (0 = indefinite)")

        while True:
            # Check if duration is reached
            if duration > 0 and (time.time() - start_time > duration):
                break

            # Capture frame
            ret, frame = cap.read()
            if not ret:
                logging.error("Failed to capture frame")
                break

            frame_count += 1

            # Run detection every 5 frames to reduce processing load
            if frame_count % 5 == 0:
                # Detect GCP markers
                results = detect_gcp_markers(frame, save_debug=False)

                # Check if any markers were detected
                has_detections = (
                    len(results['squares']) > 0 or
                    len(results['triangles']) > 0 or
                    len(results['x_patterns']) > 0 or
                    len(results['tri_in_squares']) > 0
                )

                if has_detections:
                    detection_count += 1

                    # Save frame with detections if requested
                    if save_detected:
                        timestamp = time.strftime("%Y%m%d_%H%M%S")
                        cv2.imwrite(f"{debug_dir}/gcp_detection_{timestamp}.jpg", results['display_frame'])

                # Display the frame with detections
                cv2.imshow("GCP Detection", results['display_frame'])

            # Break the loop if 'q' is pressed
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        # Clean up
        cap.release()
        cv2.destroyAllWindows()

        logging.info(f"GCP detection completed. Processed {frame_count} frames, found detections in {detection_count} frames")
        return True
    except Exception as e:
        logging.error(f"Error during GCP detection: {str(e)}")
        return False


--- detection\models.py ---
"""
Detection Models Module
---------------------
Functions for loading and utilizing object detection models.
"""

import logging
import torch
import os
from ultralytics import YOLO
import cv2
import time
import numpy as np

def load_detection_model(model_path):
    """
    Load a YOLO object detection model.

    Args:
        model_path: Path to the model file

    Returns:
        Loaded model or None if loading failed
    """
    try:
        # Verify model file exists
        if not os.path.exists(model_path):
            logging.error(f"Model file not found: {model_path}")
            return None

        # Determine device (GPU if available, otherwise CPU)
        device = 'cuda' if torch.cuda.is_available() else 'cpu'
        logging.info(f"Loading model on device: {device}")

        # Load model
        model = YOLO(model_path)
        model.to(device)

        logging.info(f"Model loaded successfully from {model_path}")
        return model
    except Exception as e:
        logging.error(f"Error loading detection model: {str(e)}")
        return None

def test_detection_model(model, test_source="0", threshold=0.5, duration=10):
    """
    Test the detection model using a camera feed or test image/video.

    Args:
        model: The loaded detection model
        test_source: Source for testing (0 for webcam, or path to image/video)
        threshold: Detection confidence threshold
        duration: Test duration in seconds (for webcam only)

    Returns:
        True if test was successful, False otherwise
    """
    if model is None:
        logging.error("No model provided for testing")
        return False

    try:
        logging.info(f"Testing detection model on source: {test_source}")

        # Create debug frames directory if it doesn't exist
        debug_dir = "debug_frames"
        if not os.path.exists(debug_dir):
            os.makedirs(debug_dir)

        # For webcam, test for a limited duration
        if test_source == "0" or test_source == 0:
            cap = cv2.VideoCapture(0)
            if not cap.isOpened():
                logging.error("Cannot open camera")
                return False

            start_time = time.time()
            frame_count = 0
            detection_count = 0

            while time.time() - start_time < duration:
                ret, frame = cap.read()
                if not ret:
                    logging.error("Failed to capture frame")
                    break

                # Run detection on frame
                results = model.predict(
                    source=frame,
                    conf=threshold,
                    show=True,
                    save=False
                )

                # Count detected objects
                if len(results) > 0 and len(results[0].boxes) > 0:
                    detection_count += 1

                    # Draw bounding boxes on the frame
                    result_frame = results[0].plot()

                    # Save frame with detections
                    cv2.imwrite(f"{debug_dir}/detection_{frame_count}.jpg", result_frame)

                    # Log detection details
                    for box in results[0].boxes:
                        if hasattr(box, 'cls') and hasattr(box, 'conf'):
                            class_id = int(box.cls[0]) if hasattr(box.cls, '__getitem__') else int(box.cls)
                            confidence = float(box.conf[0]) if hasattr(box.conf, '__getitem__') else float(box.conf)
                            class_name = results[0].names[class_id] if hasattr(results[0], 'names') else f"Class {class_id}"
                            logging.info(f"Detected {class_name} with confidence {confidence:.2f}")

                frame_count += 1

                # Process key presses
                if cv2.waitKey(1) == ord('q'):
                    break

            # Clean up
            cap.release()
            cv2.destroyAllWindows()

            logging.info(f"Test completed. Processed {frame_count} frames, detected objects in {detection_count} frames")
            return True

        else:
            # For image or video file
            results = model.predict(
                source=test_source,
                conf=threshold,
                show=True,
                save=True,
                save_txt=True,
                save_conf=True,
                project=debug_dir,
                name="test_results"
            )

            # Count detections
            detection_count = sum(1 for r in results if len(r.boxes) > 0)

            # Log detection details
            for i, result in enumerate(results):
                if len(result.boxes) > 0:
                    for box in result.boxes:
                        if hasattr(box, 'cls') and hasattr(box, 'conf'):
                            class_id = int(box.cls[0]) if hasattr(box.cls, '__getitem__') else int(box.cls)
                            confidence = float(box.conf[0]) if hasattr(box.conf, '__getitem__') else float(box.conf)
                            class_name = result.names[class_id] if hasattr(result, 'names') else f"Class {class_id}"
                            logging.info(f"Frame {i}: Detected {class_name} with confidence {confidence:.2f}")

            logging.info(f"Test completed. Detected objects in {detection_count} frames")
            return True

    except Exception as e:
        logging.error(f"Error testing detection model: {str(e)}")
        return False

def run_detection(model, source, threshold=0.5, classes=None, save_results=False, output_dir="detection_results"):
    """
    Run object detection on a source (camera, image, video).

    Args:
        model: The loaded detection model
        source: Source for detection (0 for webcam, or path to image/video)
        threshold: Detection confidence threshold
        classes: List of class IDs to detect, None for all classes
        save_results: Whether to save results to disk
        output_dir: Directory to save results

    Returns:
        Generator yielding detection results
    """
    if model is None:
        logging.error("No model provided for detection")
        return None

    try:
        # Configure result saving if enabled
        save_args = {}
        if save_results:
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)

            save_args = {
                'save': True,
                'save_txt': True,
                'save_conf': True,
                'project': output_dir,
                'name': f"detection_{time.strftime('%Y%m%d_%H%M%S')}"
            }

        # Run detection
        results = model.predict(
            source=source,
            conf=threshold,
            classes=classes,
            stream=True,  # Enable streaming for real-time processing
            **save_args
        )

        # Return results generator
        return results

    except Exception as e:
        logging.error(f"Error running detection: {str(e)}")
        return None

def process_detection_results(results, frame=None, display=False):
    """
    Process detection results for a frame.

    Args:
        results: Detection results from model.predict
        frame: Original frame (if available)
        display: Whether to display the frame with detections

    Returns:
        List of detected objects with their details
    """
    try:
        detections = []

        # Process results for this frame
        for result in results:
            # Skip empty results
            if not hasattr(result, 'boxes') or len(result.boxes) == 0:
                continue

            # Get the original image
            img = result.orig_img if frame is None else frame.copy()

            # Process each detection
            for i, box in enumerate(result.boxes):
                # Get box coordinates
                if hasattr(box, 'xyxy') and len(box.xyxy) > 0:
                    x1, y1, x2, y2 = map(int, box.xyxy[0])
                elif hasattr(box, 'xywh') and len(box.xywh) > 0:
                    x, y, w, h = map(int, box.xywh[0])
                    x1, y1 = x - w//2, y - h//2
                    x2, y2 = x + w//2, y + h//2
                else:
                    logging.warning("Box coordinates not found in result")
                    continue

                # Get confidence and class
                if hasattr(box, 'conf') and len(box.conf) > 0:
                    confidence = float(box.conf[0])
                else:
                    confidence = 0.0

                if hasattr(box, 'cls') and len(box.cls) > 0:
                    class_id = int(box.cls[0])
                    class_name = result.names[class_id] if hasattr(result, 'names') else f"Class {class_id}"
                else:
                    class_id = -1
                    class_name = "Unknown"

                # Calculate center point
                center_x = int((x1 + x2) / 2)
                center_y = int((y1 + y2) / 2)

                # Create detection object
                detection = {
                    'id': i,
                    'class_id': class_id,
                    'class_name': class_name,
                    'confidence': confidence,
                    'bbox': (x1, y1, x2, y2),
                    'center': (center_x, center_y),
                    'width': x2 - x1,
                    'height': y2 - y1,
                    'area': (x2 - x1) * (y2 - y1)
                }

                detections.append(detection)

                # Draw on image if display is enabled
                if display and img is not None:
                    # Draw bounding box
                    cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)

                    # Draw center point
                    cv2.circle(img, (center_x, center_y), 5, (0, 0, 255), -1)

                    # Draw label
                    label = f"{class_name} {confidence:.2f}"
                    cv2.putText(
                        img, label, (x1, y1 - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2
                    )

            # Display the image
            if display and img is not None:
                cv2.imshow("Detections", img)
                cv2.waitKey(1)

        return detections

    except Exception as e:
        logging.error(f"Error processing detection results: {str(e)}")
        return []

def save_detection_image(image, detections, output_dir="detection_results", filename=None):
    """
    Save an image with detection boxes drawn on it.

    Args:
        image: The original image
        detections: List of detection dictionaries from process_detection_results
        output_dir: Directory to save the image
        filename: Filename (if None, use timestamp)

    Returns:
        Path to saved file or None if save failed
    """
    if image is None or len(detections) == 0:
        logging.error("Missing image or detections")
        return None

    try:
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Generate filename based on timestamp if not provided
        if filename is None:
            filename = f"detection_{time.strftime('%Y%m%d_%H%M%S')}.jpg"

        # Full path to save the image
        file_path = os.path.join(output_dir, filename)

        # Create a copy of the image to draw on
        result_image = image.copy()

        # Draw each detection
        for detection in detections:
            # Extract detection info
            x1, y1, x2, y2 = detection['bbox']
            class_name = detection['class_name']
            confidence = detection['confidence']
            center_x, center_y = detection['center']

            # Draw bounding box
            cv2.rectangle(result_image, (x1, y1), (x2, y2), (0, 255, 0), 2)

            # Draw center point
            cv2.circle(result_image, (center_x, center_y), 5, (0, 0, 255), -1)

            # Draw label
            label = f"{class_name} {confidence:.2f}"
            cv2.putText(
                result_image, label, (x1, y1 - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2
            )

        # Save the image
        cv2.imwrite(file_path, result_image)
        logging.info(f"Detection image saved to {file_path}")

        return file_path
    except Exception as e:
        logging.error(f"Error saving detection image: {str(e)}")
        return None


--- detection\video_recorder.py ---
# detection/video_recorder.py - NEW MODULE
"""
Video Recording Module
---------------------
Functions for recording camera footage during missions.
"""

import cv2
import time
import logging
import os
import threading
from datetime import datetime
from typing import Optional

class VideoRecorder:
    """Video recorder class for mission recording"""

    def __init__(self, output_dir="recordings", fps=30.0, codec='XVID'):
        self.output_dir = output_dir
        self.fps = fps
        self.codec = codec
        self.recording = False
        self.writer = None
        self.cap = None
        self.record_thread = None
        self.current_filename = None

        # Create output directory
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

    def start_recording(self, camera_id=0, resolution=(640, 480), mission_name="mission"):
        """
        Start recording video from camera.

        Args:
            camera_id: Camera ID to record from
            resolution: Video resolution (width, height)
            mission_name: Name of mission for filename

        Returns:
            True if recording started successfully
        """
        if self.recording:
            logging.warning("Recording already in progress")
            return False

        try:
            # Initialize camera
            self.cap = cv2.VideoCapture(camera_id)
            if not self.cap.isOpened():
                logging.error(f"Failed to open camera {camera_id}")
                return False

            # Set camera resolution
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, resolution[0])
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, resolution[1])
            self.cap.set(cv2.CAP_PROP_FPS, self.fps)

            # Test frame capture
            ret, frame = self.cap.read()
            if not ret:
                logging.error("Failed to capture test frame")
                self.cap.release()
                return False

            # Generate filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.current_filename = f"{mission_name}_{timestamp}.avi"
            full_path = os.path.join(self.output_dir, self.current_filename)

            # Initialize video writer
            fourcc = cv2.VideoWriter_fourcc(*self.codec)
            actual_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            actual_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

            self.writer = cv2.VideoWriter(full_path, fourcc, self.fps, (actual_width, actual_height))

            if not self.writer.isOpened():
                logging.error("Failed to initialize video writer")
                self.cap.release()
                return False

            # Start recording thread
            self.recording = True
            self.record_thread = threading.Thread(target=self._record_loop)
            self.record_thread.daemon = True
            self.record_thread.start()

            logging.info(f"Recording started: {full_path}")
            logging.info(f"Resolution: {actual_width}x{actual_height} @ {self.fps} FPS")

            return True

        except Exception as e:
            logging.error(f"Error starting recording: {str(e)}")
            self.cleanup()
            return False

    def _record_loop(self):
        """Main recording loop (runs in separate thread)"""
        frame_count = 0
        start_time = time.time()

        try:
            while self.recording and self.cap and self.cap.isOpened():
                ret, frame = self.cap.read()

                if not ret:
                    logging.warning("Failed to capture frame, stopping recording")
                    break

                # Write frame to video file
                if self.writer:
                    self.writer.write(frame)
                    frame_count += 1

                # Brief sleep to prevent 100% CPU usage
                time.sleep(0.001)

        except Exception as e:
            logging.error(f"Error in recording loop: {str(e)}")

        # Calculate recording stats
        duration = time.time() - start_time
        actual_fps = frame_count / duration if duration > 0 else 0

        logging.info(f"Recording stopped: {frame_count} frames in {duration:.1f}s ({actual_fps:.1f} FPS)")

    def stop_recording(self):
        """Stop recording and save file"""
        if not self.recording:
            logging.warning("No recording in progress")
            return False

        try:
            self.recording = False

            # Wait for recording thread to finish
            if self.record_thread:
                self.record_thread.join(timeout=5)

            self.cleanup()

            if self.current_filename:
                full_path = os.path.join(self.output_dir, self.current_filename)
                if os.path.exists(full_path):
                    file_size = os.path.getsize(full_path) / (1024 * 1024)  # MB
                    logging.info(f"Recording saved: {full_path} ({file_size:.1f} MB)")
                    return True
                else:
                    logging.error("Recording file not found after stopping")
                    return False

            return True

        except Exception as e:
            logging.error(f"Error stopping recording: {str(e)}")
            return False

    def cleanup(self):
        """Clean up resources"""
        try:
            if self.writer:
                self.writer.release()
                self.writer = None

            if self.cap:
                self.cap.release()
                self.cap = None

        except Exception as e:
            logging.error(f"Error during cleanup: {str(e)}")

    def is_recording(self):
        """Check if currently recording"""
        return self.recording

    def get_current_filename(self):
        """Get current recording filename"""
        return self.current_filename

def create_video_recorder(output_dir="recordings", fps=30.0, codec='XVID'):
    """
    Factory function to create a video recorder.

    Args:
        output_dir: Directory to save recordings
        fps: Frames per second
        codec: Video codec ('XVID', 'MJPG', 'H264')

    Returns:
        VideoRecorder instance
    """
    return VideoRecorder(output_dir, fps, codec)

def test_video_recording(camera_id=0, duration=10, output_dir="test_recordings"):
    """
    Test video recording functionality.

    Args:
        camera_id: Camera ID to use
        duration: Recording duration in seconds
        output_dir: Output directory for test recording

    Returns:
        True if test successful
    """
    try:
        logging.info(f"Testing video recording for {duration} seconds")

        recorder = create_video_recorder(output_dir)

        # Start recording
        if not recorder.start_recording(camera_id, mission_name="test"):
            logging.error("Failed to start test recording")
            return False

        # Record for specified duration
        time.sleep(duration)

        # Stop recording
        if not recorder.stop_recording():
            logging.error("Failed to stop test recording")
            return False

        logging.info("Video recording test completed successfully")
        return True

    except Exception as e:
        logging.error(f"Error during video recording test: {str(e)}")
        return False


--- drone\connection.py ---
"""
Drone Connection Module
----------------------
Functions for connecting to and managing the drone vehicle using pymavlink.
"""

import time
import logging
import math
from pymavlink import mavutil

def connect_vehicle(connection_string):
    """
    Connect to the drone vehicle using pymavlink.

    Args:
        connection_string: The connection string (e.g., 'tcp:127.0.0.1:5761')

    Returns:
        The connected mavlink object or None if connection failed
    """
    try:
        logging.info(f"Connecting to vehicle on: {connection_string}")

        # Parse the connection string
        if connection_string.startswith('tcp:'):
            # TCP connection (e.g., 'tcp:127.0.0.1:5761')
            vehicle = mavutil.mavlink_connection(connection_string)
        elif connection_string.startswith('udp:'):
            # UDP connection (e.g., 'udp:127.0.0.1:14550')
            vehicle = mavutil.mavlink_connection(connection_string)
        elif ',' in connection_string:
            # Serial connection with baud rate (e.g., '/dev/ttyUSB0,57600')
            parts = connection_string.split(',')
            if len(parts) == 2:
                port, baud = parts
                vehicle = mavutil.mavlink_connection(port, baud=int(baud))
            else:
                logging.error(f"Invalid serial connection string: {connection_string}")
                return None
        else:
            # Assume it's a serial port with default baud rate
            vehicle = mavutil.mavlink_connection(connection_string, baud=57600)

        # Wait for the heartbeat to ensure connection is established
        logging.info("Waiting for heartbeat...")
        vehicle.wait_heartbeat()

        logging.info(f"Connected to vehicle (system: {vehicle.target_system}, component: {vehicle.target_component})")
        return vehicle
    except Exception as e:
        logging.error(f"Error connecting to vehicle: {str(e)}")
        return None

def close_vehicle(vehicle):
    """
    Safely close the connection to the vehicle.

    Args:
        vehicle: The connected mavlink object
    """
    if vehicle:
        try:
            vehicle.close()
            logging.info("Vehicle connection closed")
        except Exception as e:
            logging.error(f"Error closing vehicle connection: {str(e)}")

def get_vehicle_state(vehicle):
    """
    Get the current state of the vehicle.

    Args:
        vehicle: The connected mavlink object

    Returns:
        Dictionary containing vehicle state information
    """
    if not vehicle:
        return None

    try:
        # Request current parameters and system status
        vehicle.mav.param_request_list_send(
            vehicle.target_system, vehicle.target_component
        )

        vehicle.mav.request_data_stream_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_ALL,
            1,  # Rate in Hz
            1   # Start/stop (1=start, 0=stop)
        )

        # Initialize state dictionary
        state = {
            "mode": None,
            "armed": None,
            "system_status": None,
            "gps_fix_type": None,
            "altitude": None,
            "location": {"lat": None, "lon": None, "alt": None},
            "attitude": {"roll": None, "pitch": None, "yaw": None},
            "velocity": {"vx": None, "vy": None, "vz": None},
            "battery": {"voltage": None, "current": None, "remaining": None}
        }

        # Wait for and process messages to populate state data
        start_time = time.time()
        timeout = 3  # seconds

        while time.time() - start_time < timeout:
            msg = vehicle.recv_match(blocking=False)
            if not msg:
                time.sleep(0.1)
                continue

            msg_type = msg.get_type()

            if msg_type == "HEARTBEAT":
                state["armed"] = (msg.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0
                state["mode"] = mavutil.mode_string_v10(msg)
                state["system_status"] = msg.system_status
            elif msg_type == "GLOBAL_POSITION_INT":
                state["location"]["lat"] = msg.lat / 1e7
                state["location"]["lon"] = msg.lon / 1e7
                state["location"]["alt"] = msg.alt / 1000.0  # Convert mm to m
                state["altitude"] = msg.relative_alt / 1000.0  # Convert mm to m
            elif msg_type == "ATTITUDE":
                state["attitude"]["roll"] = math.degrees(msg.roll)
                state["attitude"]["pitch"] = math.degrees(msg.pitch)
                state["attitude"]["yaw"] = math.degrees(msg.yaw)
            elif msg_type == "GPS_RAW_INT":
                state["gps_fix_type"] = msg.fix_type
            elif msg_type == "VFR_HUD":
                state["groundspeed"] = msg.groundspeed
                state["airspeed"] = msg.airspeed
                state["heading"] = msg.heading
            elif msg_type == "SYS_STATUS":
                state["battery"]["voltage"] = msg.voltage_battery / 1000.0  # Convert mV to V
                state["battery"]["current"] = msg.current_battery / 100.0  # Convert 10*mA to A
                state["battery"]["remaining"] = msg.battery_remaining

        return state
    except Exception as e:
        logging.error(f"Error getting vehicle state: {str(e)}")
        return None

def print_vehicle_state(vehicle):
    """
    Print the current state of the vehicle to the console.

    Args:
        vehicle: The connected mavlink object
    """
    state = get_vehicle_state(vehicle)
    if state:
        logging.info("===== Vehicle State =====")

        # Format mode and armed status
        logging.info(f"Mode: {state['mode']}")
        logging.info(f"Armed: {state['armed']}")

        # Format location
        lat = state['location']['lat']
        lon = state['location']['lon']
        alt = state['location']['alt']
        rel_alt = state['altitude']
        if lat is not None and lon is not None:
            logging.info(f"Location: Lat={lat}, Lon={lon}, Alt={alt}m (Relative Alt={rel_alt}m)")

        # Format attitude
        roll = state['attitude']['roll']
        pitch = state['attitude']['pitch']
        yaw = state['attitude']['yaw']
        if roll is not None:
            logging.info(f"Attitude: Roll={roll}°, Pitch={pitch}°, Yaw={yaw}°")

        # Format battery
        voltage = state['battery']['voltage']
        current = state['battery']['current']
        remaining = state['battery']['remaining']
        if voltage is not None:
            logging.info(f"Battery: Voltage={voltage}V, Current={current}A, Remaining={remaining}%")

        # Format GPS
        logging.info(f"GPS Fix Type: {state['gps_fix_type']}")

        # Format velocity
        if 'groundspeed' in state:
            logging.info(f"Groundspeed: {state['groundspeed']} m/s")
            logging.info(f"Airspeed: {state['airspeed']} m/s")
            logging.info(f"Heading: {state['heading']}°")

        logging.info("========================")
    else:
        logging.warning("Could not retrieve vehicle state")

def request_message_interval(vehicle, message_id, frequency_hz):
    """
    Request a specific mavlink message at a given frequency.

    Args:
        vehicle: The connected mavlink object
        message_id: The MAVLink message ID to request
        frequency_hz: The frequency in Hz to request (0 means stop)

    Returns:
        True if the request was sent, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Calculate message interval in microseconds
        if frequency_hz == 0:
            interval = 0  # 0 means stop
        else:
            interval = int(1000000 / frequency_hz)

        # Request message interval
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,                  # Confirmation
            message_id,         # Param 1: Message ID
            interval,           # Param 2: Interval in microseconds
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        return True
    except Exception as e:
        logging.error(f"Error setting message interval: {str(e)}")
        return False

def wait_for_message(vehicle, message_type, timeout=5):
    """
    Wait for a specific MAVLink message type.

    Args:
        vehicle: The connected mavlink object
        message_type: The MAVLink message type to wait for
        timeout: Maximum time to wait in seconds

    Returns:
        The received message or None if timeout
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return None

    try:
        start_time = time.time()
        while time.time() - start_time < timeout:
            msg = vehicle.recv_match(type=message_type, blocking=True, timeout=0.5)
            if msg:
                return msg

        logging.warning(f"Timeout waiting for {message_type} message")
        return None
    except Exception as e:
        logging.error(f"Error waiting for message: {str(e)}")
        return None

# --- drone/connection.py ---
def get_vehicle_diagnostics(vehicle, timeout=10):
    """
    Get comprehensive diagnostics for the vehicle.

    Args:
        vehicle: The connected mavlink object
        timeout: Maximum time to collect diagnostics in seconds

    Returns:
        Dictionary containing diagnostic information
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return None

    try:
        # Initialize diagnostics dictionary
        diagnostics = {
            "connection": {
                "target_system": getattr(vehicle, 'target_system', 'Unknown'),
                "target_component": getattr(vehicle, 'target_component', 'Unknown'),
                "connection_string": getattr(vehicle, 'address', 'Unknown'),
            },
            "heartbeat_received": False,
            "status_text_messages": [],
            "pre_arm_status": [],
            "gps_status": None,
            "mode": None,
            "armed": None,
            "params_received": False,
            "firmware_version": None
        }

        # Request parameters and system status
        vehicle.mav.param_request_list_send(
            getattr(vehicle, 'target_system', 1),
            getattr(vehicle, 'target_component', 0)
        )

        # Request data streams
        vehicle.mav.request_data_stream_send(
            getattr(vehicle, 'target_system', 1),
            getattr(vehicle, 'target_component', 0),
            mavutil.mavlink.MAV_DATA_STREAM_ALL,
            4,  # 4 Hz
            1   # Start
        )

        # Collect messages for the specified timeout
        start_time = time.time()
        while time.time() - start_time < timeout:
            msg = vehicle.recv_match(blocking=False)
            if not msg:
                time.sleep(0.1)
                continue

            msg_type = msg.get_type()

            # Process message based on type
            if msg_type == "HEARTBEAT":
                diagnostics["heartbeat_received"] = True
                diagnostics["armed"] = (msg.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0
                try:
                    if hasattr(mavutil, 'mode_string_v10') and callable(mavutil.mode_string_v10):
                        diagnostics["mode"] = mavutil.mode_string_v10(msg)
                    else:
                        diagnostics["mode"] = f"Mode ID: {msg.custom_mode}"
                except:
                    diagnostics["mode"] = f"Mode ID: {msg.custom_mode}"

            elif msg_type == "STATUSTEXT":
                message_text = msg.text if hasattr(msg, 'text') else "Unknown status"
                diagnostics["status_text_messages"].append(message_text)

                # Check for pre-arm status
                if "PreArm" in message_text:
                    diagnostics["pre_arm_status"].append(message_text)

            elif msg_type == "GPS_RAW_INT":
                diagnostics["gps_status"] = {
                    "fix_type": msg.fix_type,
                    "satellites_visible": msg.satellites_visible
                }

            elif msg_type == "AUTOPILOT_VERSION":
                # Extract version information
                flight_sw_version = msg.flight_sw_version
                major = (flight_sw_version >> 24) & 0xFF
                minor = (flight_sw_version >> 16) & 0xFF
                patch = (flight_sw_version >> 8) & 0xFF
                diagnostics["firmware_version"] = f"{major}.{minor}.{patch}"

            elif msg_type == "PARAM_VALUE":
                diagnostics["params_received"] = True

        return diagnostics
    except Exception as e:
        logging.error(f"Error getting vehicle diagnostics: {str(e)}")
        return None

# --- drone/connection.py ---
def reset_flight_controller(vehicle):
    """
    Attempt to reset the flight controller.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if reset command was sent successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.warning("Sending reboot command to flight controller")

        # Send reboot command
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 0)

        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN,
            0,                  # Confirmation
            1,                  # Param 1: 1=reboot autopilot
            0,                  # Param 2: 0=do nothing for onboard computer
            0,                  # Param 3: reserved
            0,                  # Param 4: reserved
            0, 0, 0             # Params 5-7 (not used)
        )

        logging.info("Reboot command sent. Wait for flight controller to restart.")
        return True
    except Exception as e:
        logging.error(f"Error sending reboot command: {str(e)}")
        return False


--- drone\navigation.py ---
"""
Drone Navigation Module
---------------------
Functions for controlling the drone's flight using pymavlink, including arming,
takeoff, landing, waypoint navigation, and movement.
"""

import time
import math
import logging
from pymavlink import mavutil

def is_armable(vehicle):
    """
    Simplified armability check that just verifies GPS and basic connectivity.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if basic requirements met, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Running simplified armability check...")

        # Get GPS status
        gps_msg = vehicle.recv_match(type='GPS_RAW_INT', blocking=True, timeout=3)
        if gps_msg:
            gps_ok = gps_msg.fix_type >= 3 and gps_msg.satellites_visible >= 6
            logging.info(f"GPS: Fix type {gps_msg.fix_type}, {gps_msg.satellites_visible} satellites - {'OK' if gps_ok else 'NOT READY'}")
        else:
            logging.warning("No GPS data received")
            gps_ok = False

        # Get heartbeat
        heartbeat = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=3)
        if heartbeat:
            logging.info(f"Heartbeat received from system {vehicle.target_system}")
            heartbeat_ok = True
        else:
            logging.warning("No heartbeat received")
            heartbeat_ok = False

        # Simple check: GPS + Heartbeat = ready to attempt arm
        ready = gps_ok and heartbeat_ok
        logging.info(f"Simplified armability: {'READY' if ready else 'NOT READY'}")

        return ready

    except Exception as e:
        logging.error(f"Error in simplified armability check: {str(e)}")
        return False

def request_message_interval(vehicle, message_id, frequency_hz):
    """
    Request a specific mavlink message at a given frequency.

    Args:
        vehicle: The connected mavlink object
        message_id: The MAVLink message ID to request
        frequency_hz: The frequency in Hz to request (0 means stop)

    Returns:
        True if the request was sent, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Calculate message interval in microseconds
        if frequency_hz == 0:
            interval = 0  # 0 means stop
        else:
            interval = int(1000000 / frequency_hz)

        # Ensure target_system and target_component are accessible
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 1)

        # Request message interval
        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,                  # Confirmation
            message_id,         # Param 1: Message ID
            interval,           # Param 2: Interval in microseconds
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        return True
    except Exception as e:
        logging.error(f"Error setting message interval: {str(e)}")
        return False

def set_mode(vehicle, mode_name):
    """
    Set the vehicle mode.

    Args:
        vehicle: The connected mavlink object
        mode_name: The mode to set (e.g., "GUIDED", "AUTO", "LOITER")

    Returns:
        True if mode was set successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Get mode ID from name
        try:
            # Direct mode ID mapping for common modes
            mode_mapping = {
                "GUIDED": 4,
                "AUTO": 3,
                "LOITER": 5,
                "RTL": 6,
                "STABILIZE": 0,
                "ALT_HOLD": 2,
                "LAND": 9
            }

            if mode_name in mode_mapping:
                mode_id = mode_mapping[mode_name]
            else:
                logging.error(f"Unsupported mode: {mode_name}")
                return False

        except Exception as e:
            logging.error(f"Invalid mode name: {mode_name}. Error: {str(e)}")
            return False

        # Set mode
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 1)

        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_DO_SET_MODE,
            0,                      # Confirmation
            mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,
            mode_id,                # Param 2: Custom mode
            0, 0, 0, 0, 0           # Params 3-7 (not used)
        )

        # Wait for mode change to take effect
        start_time = time.time()
        while time.time() - start_time < 5:  # 5 second timeout
            msg = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=1)
            if msg:
                current_mode = "UNKNOWN"
                try:
                    # Try to get the mode string, but handle if mode_string_v10 is a function
                    if callable(mavutil.mode_string_v10):
                        current_mode = mavutil.mode_string_v10(msg)
                    else:
                        current_mode = str(msg.base_mode)
                except:
                    pass

                # Just check if armed flag changed correctly as a fallback
                # This isn't perfect but helps for testing
                logging.info(f"Current mode reported as: {current_mode}")
                if current_mode == mode_name:
                    logging.info(f"Mode changed to {mode_name}")
                    return True

        logging.warning(f"Timed out waiting for mode change to {mode_name}")
        # For testing purposes, we'll return True anyway
        logging.info(f"Assuming mode change to {mode_name} was successful despite timeout")
        return True
    except Exception as e:
        logging.error(f"Error setting mode to {mode_name}: {str(e)}")
        return False

def arm_vehicle(vehicle, force=False):
    """
    Arm the vehicle with improved verification.

    Args:
        vehicle: The connected mavlink object
        force: If True, attempt to arm even if pre-arm checks fail

    Returns:
        True if arming was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Check if already armed
        if check_if_armed(vehicle):
            logging.info("Vehicle is already armed")
            return True

        # Request pre-arm status before attempting to arm
        logging.info("Checking pre-arm status...")

        # Try to get pre-arm check messages
        got_prearm_status = False
        prearm_failing = False
        start_time = time.time()

        # Clear message buffer
        while vehicle.recv_match(blocking=False):
            pass

        # Request status text messages
        vehicle.mav.command_long_send(
            getattr(vehicle, 'target_system', 1),
            getattr(vehicle, 'target_component', 0),
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            0,
            mavutil.mavlink.MAVLINK_MSG_ID_STATUSTEXT,
            100000,  # 10Hz in microseconds
            0, 0, 0, 0, 0
        )

        # Wait for status texts
        while time.time() - start_time < 3:  # 3 seconds timeout
            msg = vehicle.recv_match(type='STATUSTEXT', blocking=False)
            if msg and hasattr(msg, 'text'):
                text = msg.text
                logging.info(f"Status: {text}")
                if "PreArm" in text:
                    got_prearm_status = True
                    if "PreArm: All checks passing" not in text:
                        prearm_failing = True
                        logging.warning(f"Pre-arm check failing: {text}")
            time.sleep(0.1)

        # If forcing or pre-arm checks pass, attempt to arm
        if force or not prearm_failing:
            logging.info("Arming motors (using ArduPilot method)")

            # Try ArduPilot-specific arming method first
            if hasattr(vehicle, 'arducopter_arm'):
                try:
                    vehicle.arducopter_arm()
                    # Wait for arm confirmation
                    start_time = time.time()

                    # Keep trying until timeout
                    arducopter_arm_succeeded = False
                    while time.time() - start_time < 5:  # 5 second timeout
                        # If ArduPilot method has a direct way to check the result, use it
                        if hasattr(vehicle, 'motors_armed') and vehicle.motors_armed():
                            logging.info("Vehicle armed successfully using ArduPilot method")
                            arducopter_arm_succeeded = True
                            return True

                        # Also check using our standard method
                        if check_if_armed(vehicle):
                            logging.info("Vehicle armed successfully using ArduPilot method")
                            arducopter_arm_succeeded = True
                            return True

                        time.sleep(0.5)

                    # Even if we couldn't verify, if Arduino didn't raise an exception,
                    # we'll assume it worked
                    if not arducopter_arm_succeeded:
                        logging.warning("ArduPilot arming succeeded but couldn't verify. Assuming armed.")
                        return True

                except Exception as e:
                    logging.warning(f"ArduPilot arm method failed: {str(e)}")

            # Fall back to generic MAVLink method if ArduPilot method failed
            logging.info("Arming motors (using MAVLink method)")
            target_system = getattr(vehicle, 'target_system', 1)
            target_component = getattr(vehicle, 'target_component', 0)

            vehicle.mav.command_long_send(
                target_system,
                target_component,
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                0,                  # Confirmation
                1,                  # Param 1: 1 to arm, 0 to disarm
                force and 21196 or 0,  # Param 2: Force (21196 is magic number for force)
                0, 0, 0, 0, 0       # Params 3-7 (not used)
            )

            # Wait for arm to take effect
            start_time = time.time()
            while time.time() - start_time < 5:  # 5 second timeout
                if check_if_armed(vehicle):
                    logging.info("Vehicle armed successfully using MAVLink method")
                    return True
                time.sleep(0.5)

            logging.warning("Timed out waiting for arm")
            return False
        else:
            if not got_prearm_status:
                logging.warning("No pre-arm status received. Vehicle likely not ready to arm.")
            else:
                logging.warning("Vehicle is not ready to arm - pre-arm checks failing")

            if force:
                logging.warning("Forcing arm attempt despite pre-arm checks")
                # Implement forced arming here similar to above but with force flag
                return False
            else:
                return False
    except Exception as e:
        logging.error(f"Error arming vehicle: {str(e)}")
        return False

def disarm_vehicle(vehicle, force=False):
    """
    Disarm the vehicle.

    Args:
        vehicle: The connected mavlink object
        force: If True, attempt to disarm even if checks fail

    Returns:
        True if disarming was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Check if already disarmed
        if not check_if_armed(vehicle):
            logging.info("Vehicle is already disarmed")
            return True

        # Send disarm command
        logging.info("Disarming motors")

        # Ensure target_system and target_component are accessible
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 1)

        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            0,                  # Confirmation
            0,                  # Param 1: 1 to arm, 0 to disarm
            force and 21196 or 0,  # Param 2: Force (21196 is magic number for force)
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        # Wait for disarm to take effect
        start_time = time.time()
        while time.time() - start_time < 5:  # 5 second timeout
            if not check_if_armed(vehicle):
                logging.info("Vehicle disarmed successfully")
                return True
            time.sleep(0.5)

        logging.warning("Timed out waiting for disarm")
        return False
    except Exception as e:
        logging.error(f"Error disarming vehicle: {str(e)}")
        return False

def check_if_armed(vehicle):
    """
    Check if the vehicle is armed using multiple methods.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if armed, False if not armed, None if unknown
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return None

    try:
        # First try ArduPilot-specific method if available
        if hasattr(vehicle, 'motors_armed'):
            try:
                return vehicle.motors_armed()
            except Exception as e:
                logging.warning(f"ArduPilot motors_armed() failed: {str(e)}")

        # Fall back to heartbeat method
        # Get heartbeat message to check arm status
        msg = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=1)
        if msg:
            armed = (msg.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0
            return armed
        else:
            # Last resort: check SYS_STATUS message for armed flag
            vehicle.mav.request_data_stream_send(
                getattr(vehicle, 'target_system', 1),
                getattr(vehicle, 'target_component', 0),
                mavutil.mavlink.MAV_DATA_STREAM_EXTENDED_STATUS,
                2,  # 2 Hz
                1   # Start
            )

            start_time = time.time()
            while time.time() - start_time < 1:  # 1 second timeout
                msg = vehicle.recv_match(type='SYS_STATUS', blocking=False)
                if msg:
                    # Check if system is armed based on onboard_control_sensors_health field
                    # This is less reliable but works on some vehicles
                    armed = (msg.onboard_control_sensors_health & mavutil.mavlink.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS) != 0
                    return armed
                time.sleep(0.1)

            logging.warning("No heartbeat or status received when checking arm status")
            return None
    except Exception as e:
        logging.error(f"Error checking arm status: {str(e)}")
        return None

def get_altitude(vehicle):
    """
    Get the current altitude of the vehicle.

    Args:
        vehicle: The connected mavlink object

    Returns:
        Current relative altitude in meters or None if unknown
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return None

    try:
        # Request global position
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1)

        # Wait for position message
        msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=1)
        if msg:
            # Convert relative altitude from mm to m
            return msg.relative_alt / 1000.0
        else:
            logging.warning("No position data received when checking altitude")
            return None
    except Exception as e:
        logging.error(f"Error getting altitude: {str(e)}")
        return None


def wait_for_altitude_blocking(vehicle, target_altitude, timeout=30, tolerance=0.1):
    """
    Blocking wait for altitude with real-time feedback.

    Args:
        vehicle: The connected mavlink object
        target_altitude: Target altitude in meters
        timeout: Maximum time to wait in seconds
        tolerance: Altitude tolerance in meters

    Returns:
        True if altitude reached, False if timeout
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Waiting for altitude {target_altitude}m (tolerance: ±{tolerance}m)")

        # Request high-frequency altitude updates
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 20)

        start_time = time.time()
        last_altitude = None
        stable_count = 0
        required_stable_readings = 3

        print(f"\nWaiting for altitude {target_altitude}m...")
        print("-" * 50)

        while time.time() - start_time < timeout:
            # Get the most recent altitude reading
            current_altitude = None

            # Process recent messages to get latest altitude
            for _ in range(10):
                msg = vehicle.recv_match(blocking=False)
                if msg and msg.get_type() == "GLOBAL_POSITION_INT":
                    current_altitude = msg.relative_alt / 1000.0

            if current_altitude is not None:
                # Calculate progress
                altitude_diff = abs(current_altitude - target_altitude)
                progress_percent = min(100, (current_altitude / target_altitude) * 100) if target_altitude > 0 else 0

                # Check stability
                if altitude_diff <= tolerance:
                    stable_count += 1
                    status = f"STABLE ({stable_count}/{required_stable_readings})"
                else:
                    stable_count = 0
                    status = "CLIMBING" if current_altitude < target_altitude else "DESCENDING"

                # Real-time display
                timestamp = time.strftime("%H:%M:%S")
                print(f"\r{timestamp} | Alt: {current_altitude:6.3f}m | Target: {target_altitude:6.3f}m | Diff: {altitude_diff:+6.3f}m | {progress_percent:5.1f}% | {status}", end="", flush=True)

                # Check if reached target with stability
                if stable_count >= required_stable_readings:
                    print(f"\n✓ REACHED {target_altitude}m! (Final: {current_altitude:.3f}m)")
                    return True

                last_altitude = current_altitude

            # Safety check
            heartbeat = vehicle.recv_match(type='HEARTBEAT', blocking=False)
            if heartbeat:
                armed = mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED  # Use your fixed armed check
                if not armed:
                    print(f"\n✗ Vehicle disarmed during altitude wait!")
                    return False

            time.sleep(0.05)

        print(f"\n✗ Timeout waiting for altitude {target_altitude}m")
        return False

    except Exception as e:
        logging.error(f"Error waiting for altitude: {str(e)}")
        return False

def arm_and_takeoff(vehicle, target_altitude):
    """
    Arms the drone and takes off to the specified altitude with blocking behavior.

    Args:
        vehicle: The connected mavlink object
        target_altitude: Target altitude in meters

    Returns:
        True if takeoff was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Use simplified armability check
        logging.info("Basic pre-arm checks")
        if not is_armable(vehicle):
            logging.warning("Vehicle may not be ready - attempting arm anyway")

        # Set to GUIDED mode
        logging.info("Setting mode to GUIDED")
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Arm the vehicle
        logging.info("Arming vehicle...")
        if not arm_vehicle(vehicle):
            logging.error("Failed to arm vehicle")
            return False

        # Wait for altitude to stabilize after arming
        logging.info("Waiting 2 seconds for sensors to stabilize...")
        time.sleep(2)

        # Send takeoff command
        logging.info(f"Taking off to {target_altitude} meters")
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
            0,                  # Confirmation
            0, 0, 0, 0, 0, 0,   # Params 1-6 (not used)
            target_altitude     # Param 7: Altitude (in meters)
        )

        # Use the blocking altitude wait function
        if not wait_for_altitude_blocking(vehicle, target_altitude, timeout=60, tolerance=0.2):
            logging.error(f"Failed to reach takeoff altitude {target_altitude}m")
            return False

        logging.info(f"✓ Takeoff successful - reached {target_altitude}m")
        return True

    except Exception as e:
        logging.error(f"Error during takeoff: {str(e)}")
        return False

def return_to_launch(vehicle):
    """
    Commands the vehicle to return to the launch location.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if RTL command was sent successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Returning to launch")

        # Set to RTL mode
        if not set_mode(vehicle, "RTL"):
            logging.error("Failed to set RTL mode")
            return False

        # Monitor altitude during RTL
        start_time = time.time()
        max_rtl_time = 120  # 2 minutes timeout

        # Set up altitude reporting
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1)

        # Wait until the vehicle is close to the ground or disarmed
        while time.time() - start_time < max_rtl_time:
            # Get current altitude
            altitude = get_altitude(vehicle)
            if altitude is not None:
                logging.info(f"Altitude: {altitude:.1f} meters")

                # Check if we're close to the ground
                if altitude < 1.0:  # Less than 1 meter
                    logging.info("Vehicle has reached the ground")
                    break

            # Check if the vehicle has disarmed (landing complete)
            if not check_if_armed(vehicle):
                logging.info("Vehicle has disarmed")
                break

            time.sleep(1)

        return True
    except Exception as e:
        logging.error(f"Error during RTL: {str(e)}")
        return False

def get_location(vehicle):
    """
    Get the current location of the vehicle.

    Args:
        vehicle: The connected mavlink object

    Returns:
        Tuple (lat, lon, alt) or None if location unknown
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return None

    try:
        # Request global position
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1)

        # Wait for position message
        msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=1)
        if msg:
            # Convert lat/lon from 1e7 degrees to degrees
            lat = msg.lat / 1e7
            lon = msg.lon / 1e7
            # Convert altitude from mm to m
            alt = msg.alt / 1000.0
            rel_alt = msg.relative_alt / 1000.0

            return (lat, lon, rel_alt)
        else:
            logging.warning("No position data received")
            return None
    except Exception as e:
        logging.error(f"Error getting location: {str(e)}")
        return None

def get_distance_metres(location1, location2):
    """
    Calculate the distance between two global locations.

    Args:
        location1: Tuple (lat, lon, alt) for first location
        location2: Tuple (lat, lon, alt) for second location

    Returns:
        Distance in meters
    """
    try:
        # Extract coordinates
        lat1, lon1, _ = location1
        lat2, lon2, _ = location2

        # Approximate conversion using equirectangular approximation
        # This is simple but less accurate for large distances
        dlat = lat2 - lat1
        dlon = lon2 - lon1

        # Earth radius in meters
        radius = 6378137.0

        # Convert to radians
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        dlat_rad = math.radians(dlat)
        dlon_rad = math.radians(dlon)

        # Haversine formula
        a = (math.sin(dlat_rad/2) * math.sin(dlat_rad/2) +
             math.cos(lat1_rad) * math.cos(lat2_rad) *
             math.sin(dlon_rad/2) * math.sin(dlon_rad/2))
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        distance = radius * c

        return distance
    except Exception as e:
        logging.error(f"Error calculating distance: {str(e)}")
        return None

def get_location_metres(original_location, dNorth, dEast):
    """
    Calculate a new location given a location and offsets in meters.

    Args:
        original_location: Tuple (lat, lon, alt) for original location
        dNorth: Meters north (positive) or south (negative)
        dEast: Meters east (positive) or west (negative)

    Returns:
        Tuple (lat, lon, alt) for new location
    """
    try:
        # Extract coordinates
        lat, lon, alt = original_location

        # Earth's radius in meters
        earth_radius = 6378137.0

        # Coordinate offsets in radians
        dLat = dNorth / earth_radius
        dLon = dEast / (earth_radius * math.cos(math.radians(lat)))

        # New position in decimal degrees
        newLat = lat + math.degrees(dLat)
        newLon = lon + math.degrees(dLon)

        return (newLat, newLon, alt)
    except Exception as e:
        logging.error(f"Error calculating new location: {str(e)}")
        return None

def navigate_to_waypoint(vehicle, waypoint, altitude=None, relative=False):
    """
    Navigate to a specific waypoint.

    Args:
        vehicle: The connected mavlink object
        waypoint: Tuple (lat, lon) or (dNorth, dEast) if relative
        altitude: Target altitude (if None, use current altitude)
        relative: If True, waypoint is relative to current location

    Returns:
        True if navigation was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Set to GUIDED mode if not already
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Get current location
        current_location = get_location(vehicle)
        if not current_location:
            logging.error("Could not get current location")
            return False

        # Determine target location
        if relative:
            # Waypoint is relative to current location
            dNorth, dEast = waypoint
            logging.info(f"Navigating {dNorth}m North, {dEast}m East")
            target_location = get_location_metres(current_location, dNorth, dEast)
        else:
            # Waypoint is absolute coordinates
            target_location = (waypoint[0], waypoint[1],
                               altitude if altitude is not None else current_location[2])
            logging.info(f"Navigating to Lat: {target_location[0]}, Lon: {target_location[1]}, Alt: {target_location[2]}m")

        # Send waypoint command
        vehicle.mav.mission_item_send(
            vehicle.target_system,
            vehicle.target_component,
            0,                  # Sequence
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
            mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,
            2,                  # Current (2=guided mode)
            0,                  # Autocontinue
            0, 0, 0, 0,         # Params 1-4 (not used)
            target_location[0], # Param 5: Latitude
            target_location[1], # Param 6: Longitude
            target_location[2]  # Param 7: Altitude
        )

        # Monitor progress
        start_time = time.time()
        timeout = 120  # 2 minutes timeout

        # Set up position reporting
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 1)

        # Wait until we reach the waypoint
        while time.time() - start_time < timeout:
            # Check if we're still in GUIDED mode
            msg = vehicle.recv_match(type='HEARTBEAT', blocking=False)
            if msg and mavutil.mode_string_v10(msg) != "GUIDED":
                logging.warning("Vehicle mode changed during navigation")
                return False

            # Get current position
            current_pos = get_location(vehicle)
            if current_pos:
                # Calculate distance to target
                distance = get_distance_metres(current_pos, target_location)
                logging.info(f"Distance to waypoint: {distance:.1f} meters")

                # Check if we've reached the waypoint (within 1 meter)
                if distance is not None and distance < 1.0:
                    logging.info("Reached waypoint")
                    return True

            time.sleep(1)

        logging.warning("Navigation timed out")
        return False
    except Exception as e:
        logging.error(f"Error navigating to waypoint: {str(e)}")
        return False

def send_ned_velocity(vehicle, velocity_x, velocity_y, velocity_z, duration=0):
    """
    Send velocity commands in North-East-Down (NED) frame.

    Args:
        vehicle: The connected mavlink object
        velocity_x: Velocity North (m/s)
        velocity_y: Velocity East (m/s)
        velocity_z: Velocity Down (m/s) - positive is downward
        duration: Duration to maintain velocity (0 means just send command once)

    Returns:
        True if command was sent successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Ensure we're in GUIDED mode
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode for velocity command")
            return False

        # Build and send SET_POSITION_TARGET_LOCAL_NED message
        vehicle.mav.set_position_target_local_ned_send(
            0,                              # time_boot_ms (not used)
            vehicle.target_system,          # target_system
            vehicle.target_component,       # target_component
            mavutil.mavlink.MAV_FRAME_LOCAL_NED,  # frame
            0b0000111111000111,             # type_mask (only speeds enabled)
            0, 0, 0,                        # x, y, z positions (not used)
            velocity_x, velocity_y, velocity_z,  # vx, vy, vz velocities in m/s
            0, 0, 0,                        # ax, ay, az accelerations (not used)
            0, 0                            # yaw, yaw_rate (not used)
        )

        # If duration is specified, maintain velocity for that time
        if duration > 0:
            logging.info(f"Maintaining velocity for {duration} seconds")
            start_time = time.time()

            while time.time() - start_time < duration:
                # Send command every 0.5 seconds
                vehicle.mav.set_position_target_local_ned_send(
                    0,
                    vehicle.target_system,
                    vehicle.target_component,
                    mavutil.mavlink.MAV_FRAME_LOCAL_NED,
                    0b0000111111000111,
                    0, 0, 0,
                    velocity_x, velocity_y, velocity_z,
                    0, 0, 0,
                    0, 0
                )
                time.sleep(0.5)

            # Send zero velocity to stop
            vehicle.mav.set_position_target_local_ned_send(
                0,
                vehicle.target_system,
                vehicle.target_component,
                mavutil.mavlink.MAV_FRAME_LOCAL_NED,
                0b0000111111000111,
                0, 0, 0,
                0, 0, 0,  # Zero velocity
                0, 0, 0,
                0, 0
            )

        return True
    except Exception as e:
        logging.error(f"Error sending velocity command: {str(e)}")
        return False

def set_servo(vehicle, servo_number, pwm_value):
    """
    Set a servo to a specific PWM value.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number (1-16)
        pwm_value: PWM value (typically 1000-2000)

    Returns:
        True if command was sent successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Send DO_SET_SERVO command
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
            0,                  # Confirmation
            servo_number,       # Param 1: Servo number
            pwm_value,          # Param 2: PWM value
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        logging.info(f"Servo {servo_number} set to {pwm_value}")
        return True
    except Exception as e:
        logging.error(f"Error setting servo: {str(e)}")
        return False

def test_motors(vehicle, throttle_percentage=5, duration_per_motor=1):
    """
    Test each motor individually at a specific throttle percentage.

    Args:
        vehicle: The connected mavlink object
        throttle_percentage: Throttle percentage (0-100)
        duration_per_motor: Duration to run each motor in seconds

    Returns:
        True if all motors were tested successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Check if disarmed
        if check_if_armed(vehicle):
            logging.warning("Vehicle is armed. Disarming for safety before motor test.")
            disarm_vehicle(vehicle)

        # Enter testing mode
        logging.info(f"Testing motors at {throttle_percentage}% throttle")

        # Calculate motor test throttle value (0-1000)
        test_throttle = int(throttle_percentage * 1)  # Convert to 0-1000 range

        # Number of motors to test (assuming quadcopter)
        num_motors = 4

        # Clear any pending messages
        while vehicle.recv_match(blocking=False):
            pass

        # Test each motor
        for motor in range(1, num_motors + 1):
            logging.info(f"Testing motor {motor} at {throttle_percentage}% throttle for {duration_per_motor}s")

            # Send motor test command
            target_system = getattr(vehicle, 'target_system', 1)
            target_component = getattr(vehicle, 'target_component', 0)

            vehicle.mav.command_long_send(
                target_system,
                target_component,
                mavutil.mavlink.MAV_CMD_DO_MOTOR_TEST,
                0,                     # Confirmation
                motor,                 # Param 1: Motor instance number (1-based)
                mavutil.mavlink.MOTOR_TEST_THROTTLE_PERCENT,  # Param 2: Test type
                test_throttle,         # Param 3: Throttle value (0-1000)
                duration_per_motor,    # Param 4: Test duration in seconds
                0,                     # Param 5: Motor count (0 for all motors)
                0,                     # Param 6 (not used)
                0                      # Param 7 (not used)
            )

            # Check for command acknowledgment
            start_time = time.time()
            got_ack = False

            while time.time() - start_time < 1:  # 1 second timeout for ACK
                msg = vehicle.recv_match(type='COMMAND_ACK', blocking=False)
                if msg and msg.command == mavutil.mavlink.MAV_CMD_DO_MOTOR_TEST:
                    got_ack = True
                    if msg.result == mavutil.mavlink.MAV_RESULT_ACCEPTED:
                        logging.info(f"Motor {motor} test command accepted")
                    else:
                        logging.warning(f"Motor {motor} test command failed with result {msg.result}")
                    break
                time.sleep(0.1)

            if not got_ack:
                logging.warning(f"No acknowledgment received for motor {motor} test command")

            # Wait for the test duration plus a small buffer
            time.sleep(duration_per_motor + 0.5)

        logging.info("Motor test complete")
        return True
    except Exception as e:
        logging.error(f"Error during motor test: {str(e)}")
        return False


# --- drone/navigation.py ---
def arm_vehicle_mavlink(vehicle, force=False):
    """
    Arm vehicle using direct MAVLink commands.

    Args:
        vehicle: The connected mavlink object
        force: If True, attempt to arm even if pre-arm checks fail

    Returns:
        True if arming was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Arming vehicle with direct MAVLink method")

        # Get target system and component
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 0)

        # Send arm command
        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            0,                  # Confirmation
            1,                  # Param 1: 1 to arm, 0 to disarm
            force and 21196 or 0,  # Param 2: Force (21196 is magic number for force)
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        # Request immediate ACK from vehicle
        ack = vehicle.recv_match(type='COMMAND_ACK', blocking=True, timeout=3)
        if ack and ack.command == mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM:
            if ack.result == mavutil.mavlink.MAV_RESULT_ACCEPTED:
                logging.info("Arm command accepted by autopilot")
                # Wait a moment for the command to take effect
                time.sleep(1)
                return True
            else:
                logging.error(f"Arm command rejected with result: {ack.result}")
                return False
        else:
            logging.warning("No ACK received for arm command, checking arm state anyway")
            # Wait a moment for the command to take effect
            time.sleep(1)
            # Check if armed despite no ACK
            armed = check_if_armed_simple(vehicle)
            if armed:
                logging.info("Vehicle appears to be armed despite no ACK")
                return True
            return False

    except Exception as e:
        logging.error(f"Error in direct MAVLink arming: {str(e)}")
        return False

# --- drone/navigation.py ---
def check_if_armed_simple(vehicle):
    """
    Simple direct check if vehicle is armed using heartbeat message.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if armed, False otherwise
    """
    if not vehicle:
        return False

    try:
        # Clear buffer
        while vehicle.recv_match(blocking=False):
            pass

        # Request a fresh heartbeat
        vehicle.mav.heartbeat_send(
            mavutil.mavlink.MAV_TYPE_GCS,
            mavutil.mavlink.MAV_AUTOPILOT_INVALID,
            0, 0, 0
        )

        # Wait for heartbeat
        msg = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=1)
        if msg:
            return (msg.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0
        return False
    except:
        return False


# drone/navigation.py - FIXED FUNCTION
def run_preflight_checks(vehicle, min_gps_fix=3, min_battery=50, check_compass=True):
    """
    Run comprehensive pre-flight safety checks with proper error handling.

    Args:
        vehicle: The connected mavlink object
        min_gps_fix: Minimum GPS fix type required (3 for 3D fix)
        min_battery: Minimum battery percentage required
        check_compass: Whether to check compass calibration

    Returns:
        (bool, str): Tuple of (checks_passed, failure_reason)
    """
    if not vehicle:
        return False, "No vehicle connection"

    try:
        logging.info("Running pre-flight safety checks...")
        failures = []

        # Check 1: Vehicle heartbeat
        logging.info("Check 1: Verifying vehicle heartbeat...")
        msg = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=2)
        if not msg:
            failures.append("No heartbeat from vehicle")

        # Check 2: GPS status
        logging.info("Check 2: Verifying GPS status...")
        vehicle.mav.request_data_stream_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_POSITION, 2, 1)

        start_time = time.time()
        gps_check_passed = False
        fix_type = 0  # Initialize with default value
        satellites = 0  # Initialize with default value

        while time.time() - start_time < 3:
            msg = vehicle.recv_match(type='GPS_RAW_INT', blocking=False)
            if msg:
                fix_type = msg.fix_type
                satellites = msg.satellites_visible

                # Define fix type names
                fix_type_name = "No GPS" if fix_type == 0 else \
                               "No Fix" if fix_type == 1 else \
                               "2D Fix" if fix_type == 2 else \
                               "3D Fix" if fix_type == 3 else \
                               "3D DGPS" if fix_type == 4 else \
                               "RTK Float" if fix_type == 5 else \
                               "RTK Fixed" if fix_type == 6 else \
                               f"Fix Type {fix_type}"

                logging.info(f"GPS: {fix_type_name} with {satellites} satellites")

                if fix_type >= min_gps_fix:
                    gps_check_passed = True
                    break

            time.sleep(0.2)

        # Handle case where no GPS message was received
        if not gps_check_passed:
            if fix_type == 0:
                fix_type_name = "No GPS data received"
            else:
                fix_type_name = "No GPS" if fix_type == 0 else \
                               "No Fix" if fix_type == 1 else \
                               "2D Fix" if fix_type == 2 else \
                               "3D Fix" if fix_type == 3 else \
                               "3D DGPS" if fix_type == 4 else \
                               "RTK Float" if fix_type == 5 else \
                               "RTK Fixed" if fix_type == 6 else \
                               f"Fix Type {fix_type}"

            failures.append(f"GPS fix type below minimum required (current: {fix_type_name}, required: 3D fix or better)")

        # Check 3: Battery level
        logging.info("Check 3: Verifying battery level...")
        vehicle.mav.request_data_stream_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_EXTENDED_STATUS, 2, 1)

        start_time = time.time()
        battery_check_passed = False
        battery_remaining = -1  # Initialize with default

        while time.time() - start_time < 2:
            msg = vehicle.recv_match(type='SYS_STATUS', blocking=False)
            if msg:
                battery_remaining = msg.battery_remaining
                voltage = msg.voltage_battery / 1000.0  # Convert from mV to V

                logging.info(f"Battery: {battery_remaining}% remaining, {voltage:.2f}V")

                if battery_remaining >= min_battery:
                    battery_check_passed = True
                    break
                elif battery_remaining < 0:
                    # Some systems don't report battery percentage
                    logging.warning("Battery percentage not available, skipping check")
                    battery_check_passed = True
                    break

            time.sleep(0.2)

        if not battery_check_passed and battery_remaining >= 0:
            failures.append(f"Battery level below minimum (current: {battery_remaining}%, required: {min_battery}%)")

        # Check 4: Pre-arm status
        logging.info("Check 4: Verifying pre-arm status...")
        # Clear message buffer
        while vehicle.recv_match(blocking=False):
            pass

        # Request status text messages
        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
            mavutil.mavlink.MAVLINK_MSG_ID_STATUSTEXT, 100000, 0, 0, 0, 0, 0)

        start_time = time.time()
        prearm_failures = []

        while time.time() - start_time < 2:
            msg = vehicle.recv_match(type='STATUSTEXT', blocking=False)
            if msg and hasattr(msg, 'text'):
                text = msg.text
                if "PreArm" in text and "PreArm: All checks passing" not in text:
                    prearm_failures.append(text)

            time.sleep(0.1)

        if prearm_failures:
            failures.extend(prearm_failures)

        # Check 5: Compass check (if enabled)
        if check_compass:
            logging.info("Check 5: Verifying compass calibration...")
            vehicle.mav.request_data_stream_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_DATA_STREAM_RAW_SENSORS, 2, 1)

            # Look for compass-related failure messages
            compass_failures = [f for f in prearm_failures if "compass" in f.lower()]

            if compass_failures:
                failures.extend(compass_failures)

        # Result
        if failures:
            failure_message = "Pre-flight checks failed:\n- " + "\n- ".join(failures)
            logging.warning(failure_message)
            return False, failure_message
        else:
            logging.info("All pre-flight checks PASSED")
            return True, "All checks passed"

    except Exception as e:
        error_msg = f"Error during pre-flight checks: {str(e)}"
        logging.error(error_msg)
        return False, error_msg

# --- drone/navigation.py ---
def safe_takeoff(vehicle, target_altitude, safety_checks=True, max_drift=2.0):
    """
    Takeoff with enhanced safety features including position holding.

    Args:
        vehicle: The connected mavlink object
        target_altitude: Target altitude in meters
        safety_checks: Whether to perform pre-flight safety checks
        max_drift: Maximum allowed horizontal drift in meters

    Returns:
        True if takeoff was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Run pre-flight checks if enabled
        if safety_checks:
            checks_passed, failure_reason = run_preflight_checks(vehicle)
            if not checks_passed:
                logging.error(f"Pre-flight checks failed: {failure_reason}")
                return False

        # Record the starting location for drift monitoring
        start_location = get_location(vehicle)
        if not start_location:
            logging.error("Could not get starting location")
            return False

        logging.info(f"Starting location: Lat={start_location[0]}, Lon={start_location[1]}")

        # Set to GUIDED mode
        logging.info("Setting mode to GUIDED")
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Arm the vehicle
        logging.info("Arming vehicle")
        if not arm_vehicle(vehicle, force=False):
            logging.error("Failed to arm vehicle")
            return False

        # Start with a very slow, controlled takeoff
        logging.info(f"Taking off to {target_altitude} meters with enhanced safety")

        # Send takeoff command
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
            0,                  # Confirmation
            0, 0, 0, 0, 0, 0,   # Params 1-6 (not used)
            target_altitude     # Param 7: Altitude (in meters)
        )

        # Monitor ascent with more detailed feedback
        start_time = time.time()
        timeout = 60  # seconds timeout
        prev_altitude = 0
        stall_counter = 0

        logging.info("Beginning ascent with position monitoring")

        # Setup data streams for monitoring
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT, 5)
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_VFR_HUD, 5)

        while time.time() - start_time < timeout:
            # Check altitude progress
            altitude = get_altitude(vehicle)
            if altitude is not None:
                # Check for alt change (stall detection)
                if abs(altitude - prev_altitude) < 0.05:
                    stall_counter += 1
                else:
                    stall_counter = 0

                if stall_counter > 10:
                    logging.warning("Altitude stalled - takeoff may be interrupted")

                prev_altitude = altitude
                percent_complete = (altitude / target_altitude) * 100
                logging.info(f"Altitude: {altitude:.2f}m ({percent_complete:.1f}% complete)")

                # Check for drift
                current_location = get_location(vehicle)
                if current_location:
                    drift = get_distance_metres(start_location, current_location)
                    if drift > max_drift:
                        logging.warning(f"Excessive horizontal drift detected: {drift:.1f}m")
                        logging.warning("Attempting drift correction")

                        # Calculate direction back to start
                        start_lat, start_lon, _ = start_location
                        current_lat, current_lon, _ = current_location

                        # Simple position correction (in a real system, use a proper controller)
                        north_correction = (start_lat - current_lat) * 1e7 * 1.113195  # rough m/deg at equator
                        east_correction = (start_lon - current_lon) * 1e7 * 1.113195 * math.cos(math.radians(current_lat))

                        # Scale corrections to appropriate velocity (max 0.5 m/s)
                        correction_mag = math.sqrt(north_correction**2 + east_correction**2)
                        if correction_mag > 0:
                            scale = min(0.5, correction_mag) / correction_mag
                            north_velocity = north_correction * scale
                            east_velocity = east_correction * scale

                            # Apply correction velocity
                            send_ned_velocity(vehicle, north_velocity, east_velocity, 0, 1)
                    else:
                        logging.info(f"Horizontal position stable, drift: {drift:.1f}m")

                # Check for target altitude reached
                if altitude >= target_altitude * 0.95:
                    logging.info(f"Reached target altitude: {altitude:.2f}m")

                    # Final position hold for stability
                    logging.info("Holding position for stability")
                    time.sleep(2)

                    return True

            # Check if still armed
            if not check_if_armed(vehicle):
                logging.error("Vehicle disarmed during takeoff")
                return False

            time.sleep(1)

        logging.warning("Takeoff timed out")
        return False

    except Exception as e:
        logging.error(f"Error during safe takeoff: {str(e)}")

        # Emergency RTL if something went wrong
        try:
            logging.warning("Attempting emergency return to launch")
            return_to_launch(vehicle)
        except:
            pass

        return False


# --- drone/navigation.py ---
def verify_orientation(vehicle, tolerance_deg=10):
    """
    Verify vehicle orientation is stable before takeoff.

    Args:
        vehicle: The connected mavlink object
        tolerance_deg: Maximum tolerated degrees of rotation during check

    Returns:
        True if orientation is stable, False otherwise
    """
    try:
        logging.info("Verifying orientation stability...")

        # Request attitude data
        request_message_interval(vehicle, mavutil.mavlink.MAVLINK_MSG_ID_ATTITUDE, 10)

        # Get initial attitude
        msg = vehicle.recv_match(type='ATTITUDE', blocking=True, timeout=1)
        if not msg:
            logging.error("Could not get initial attitude data")
            return False

        initial_roll = math.degrees(msg.roll)
        initial_pitch = math.degrees(msg.pitch)
        initial_yaw = math.degrees(msg.yaw)

        logging.info(f"Initial attitude: Roll={initial_roll:.1f}°, Pitch={initial_pitch:.1f}°, Yaw={initial_yaw:.1f}°")

        # Monitor for changes over 2 seconds
        start_time = time.time()
        max_roll_change = 0
        max_pitch_change = 0
        max_yaw_change = 0

        while time.time() - start_time < 2:
            msg = vehicle.recv_match(type='ATTITUDE', blocking=False)
            if msg:
                roll = math.degrees(msg.roll)
                pitch = math.degrees(msg.pitch)
                yaw = math.degrees(msg.yaw)

                roll_change = abs(roll - initial_roll)
                pitch_change = abs(pitch - initial_pitch)

                # Handle yaw wrap-around
                yaw_change = min(abs(yaw - initial_yaw), 360 - abs(yaw - initial_yaw))

                max_roll_change = max(max_roll_change, roll_change)
                max_pitch_change = max(max_pitch_change, pitch_change)
                max_yaw_change = max(max_yaw_change, yaw_change)

            time.sleep(0.1)

        logging.info(f"Maximum attitude changes: Roll={max_roll_change:.1f}°, Pitch={max_pitch_change:.1f}°, Yaw={max_yaw_change:.1f}°")

        # Check if orientation was stable
        orientation_stable = (max_roll_change < tolerance_deg and
                              max_pitch_change < tolerance_deg and
                              max_yaw_change < tolerance_deg)

        if orientation_stable:
            logging.info("Orientation is stable")
        else:
            logging.warning("Orientation unstable - vehicle may drift after takeoff")

        return orientation_stable

    except Exception as e:
        logging.error(f"Error verifying orientation: {str(e)}")
        return False

def verify_position_hold(vehicle, duration=3, max_drift=0.5):
    """
    Verify vehicle can maintain position in GUIDED mode before takeoff.

    Args:
        vehicle: The connected mavlink object
        duration: Duration to check position hold in seconds
        max_drift: Maximum allowed drift in meters

    Returns:
        True if position hold is working, False otherwise
    """
    try:
        logging.info(f"Verifying position hold capability for {duration} seconds...")

        # Get initial position
        initial_location = get_location(vehicle)
        if not initial_location:
            logging.error("Could not get initial location")
            return False

        # Monitor position for specified duration
        start_time = time.time()
        max_distance = 0

        while time.time() - start_time < duration:
            current_location = get_location(vehicle)
            if current_location:
                distance = get_distance_metres(initial_location, current_location)
                max_distance = max(max_distance, distance)
                logging.info(f"Current drift: {distance:.2f}m")

            time.sleep(0.5)

        position_stable = max_distance <= max_drift

        if position_stable:
            logging.info(f"Position hold is stable (max drift: {max_distance:.2f}m)")
        else:
            logging.warning(f"Position hold unstable - excessive drift detected: {max_distance:.2f}m")

        return position_stable

    except Exception as e:
        logging.error(f"Error verifying position hold: {str(e)}")
        return False


--- drone\servo.py ---
"""
Drone Servo Control Module
------------------------
Functions for controlling servos for package delivery operations using pymavlink.
"""

import time
import logging
from pymavlink import mavutil

def set_servo_position(vehicle, servo_number, position):
    """
    Set a servo to a specific PWM position.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number (1-16)
        position: PWM position (typically 1000-2000)

    Returns:
        True if successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Send DO_SET_SERVO command
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
            0,                  # Confirmation
            servo_number,       # Param 1: Servo number
            position,           # Param 2: PWM position
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        # Wait for acknowledgment
        start_time = time.time()
        while time.time() - start_time < 3:  # 3 second timeout
            msg = vehicle.recv_match(type='COMMAND_ACK', blocking=True, timeout=1)
            if msg and msg.command == mavutil.mavlink.MAV_CMD_DO_SET_SERVO:
                if msg.result == mavutil.mavlink.MAV_RESULT_ACCEPTED:
                    logging.info(f"Servo {servo_number} set to position {position}")
                    return True
                else:
                    logging.warning(f"Servo command failed with result {msg.result}")
                    return False

        logging.warning("No acknowledgment received for servo command")
        # We still return True as some autopilots don't send ACK for servo commands
        logging.info(f"Servo {servo_number} set to position {position} (no ACK)")
        return True
    except Exception as e:
        logging.error(f"Error setting servo position: {str(e)}")
        return False

def operate_package_release(vehicle, servo_number=9):
    """
    Release the package by operating the release servo.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number for the release mechanism

    Returns:
        True if successful, False otherwise
    """
    try:
        logging.info("Operating package release mechanism")

        # First position - closed
        if not set_servo_position(vehicle, servo_number, 1000):
            logging.error("Failed to set initial servo position")
            return False
        time.sleep(1)

        # Second position - open to release package
        if not set_servo_position(vehicle, servo_number, 2000):
            logging.error("Failed to open release mechanism")
            return False
        time.sleep(2)

        # Return to closed position
        if not set_servo_position(vehicle, servo_number, 1000):
            logging.error("Failed to close release mechanism")
            return False

        logging.info("Package release completed")
        return True
    except Exception as e:
        logging.error(f"Error during package release: {str(e)}")
        return False

def operate_claw(vehicle, servo_number=10, open_position=2000, closed_position=1000):
    """
    Operate the claw for package delivery.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number for the claw
        open_position: PWM value for open position
        closed_position: PWM value for closed position

    Returns:
        True if successful, False otherwise
    """
    try:
        logging.info("Opening claw")
        if not set_servo_position(vehicle, servo_number, open_position):
            logging.error("Failed to open claw")
            return False
        time.sleep(2)

        logging.info("Closing claw")
        if not set_servo_position(vehicle, servo_number, closed_position):
            logging.error("Failed to close claw")
            return False

        logging.info("Claw operation completed")
        return True
    except Exception as e:
        logging.error(f"Error operating claw: {str(e)}")
        return False

def test_servo(vehicle, servo_number, min_position=1000, max_position=2000, steps=5, step_time=1):
    """
    Test a servo by moving it through a range of positions.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number to test
        min_position: Minimum PWM position
        max_position: Maximum PWM position
        steps: Number of steps between min and max
        step_time: Time to hold each position in seconds

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Testing servo {servo_number} from {min_position} to {max_position} PWM")

        # Calculate step size
        step_size = (max_position - min_position) // (steps - 1) if steps > 1 else 0

        # Move servo through each position
        for i in range(steps):
            position = min_position + (i * step_size)
            logging.info(f"Setting servo {servo_number} to position {position}")

            if not set_servo_position(vehicle, servo_number, position):
                logging.error(f"Failed to set servo to position {position}")
                return False

            time.sleep(step_time)

        # Return to neutral position
        neutral_position = (min_position + max_position) // 2
        logging.info(f"Returning servo {servo_number} to neutral position {neutral_position}")
        set_servo_position(vehicle, servo_number, neutral_position)

        logging.info(f"Servo {servo_number} test completed")
        return True
    except Exception as e:
        logging.error(f"Error during servo test: {str(e)}")
        return False

def set_servo_output_channel(vehicle, channel, output):
    """
    Set a raw servo output value.

    Args:
        vehicle: The connected mavlink object
        channel: The output channel number (0-based)
        output: The output value (typically 1000-2000)

    Returns:
        True if successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Convert channel to 1-based for the MAVLink command
        servo_number = channel + 1

        # Use DO_SET_SERVO command
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
            0,                  # Confirmation
            servo_number,       # Param 1: Servo number (1-based)
            output,             # Param 2: Output value
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        logging.info(f"Set channel {channel} to output {output}")
        return True
    except Exception as e:
        logging.error(f"Error setting servo output: {str(e)}")
        return False


def test_servo_simple(vehicle, servo_number=9, duration=1):
    """
    Test servo with high/mid/low positions for specified duration each.

    Args:
        vehicle: The connected mavlink object
        servo_number: The servo number to test (default: 9 for AUX OUT 1)
        duration: Duration to hold each position in seconds

    Returns:
        True if test completed successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Testing servo {servo_number} with high/mid/low positions")
        logging.info(f"Duration: {duration} second(s) per position")

        # Test positions (typical PWM values)
        positions = [
            ("HIGH", 2000),  # High position - rotates one way
            ("MID", 1500),   # Mid position - neutral/no movement
            ("LOW", 1000)    # Low position - rotates other way
        ]

        for position_name, pwm_value in positions:
            logging.info(f"Setting servo {servo_number} to {position_name} position ({pwm_value} PWM)")

            # Set servo position
            if not set_servo_position(vehicle, servo_number, pwm_value):
                logging.error(f"Failed to set servo to {position_name} position")
                return False

            # Hold position for specified duration
            logging.info(f"Holding {position_name} position for {duration} second(s)")
            time.sleep(duration)

        # Return to neutral position
        logging.info(f"Returning servo {servo_number} to MID position (neutral)")
        set_servo_position(vehicle, servo_number, 1500)

        logging.info("Servo test completed successfully")
        return True

    except Exception as e:
        logging.error(f"Error during servo test: {str(e)}")
        return False


--- missions\delivery.py ---
"""
Package Delivery Missions Module
-----------------------------
Functions for executing package delivery missions using pymavlink.
"""

import logging
import time
import math
from threading import Thread
import cv2
from pymavlink import mavutil

from drone.connection import get_vehicle_state  # Corrected import location
from drone.navigation import (
    arm_and_takeoff, get_location, navigate_to_waypoint,
    return_to_launch, send_ned_velocity
)
from drone.servo import operate_package_release, operate_claw
from detection.models import load_detection_model, run_detection, process_detection_results
from detection.camera import initialize_camera, capture_frame, close_camera
from detection.gcp import detect_gcp_markers

def align_to_target(vehicle, target_x, target_y, camera_x, camera_y, timeout=30):
    """
    Align the drone to a detected target.

    Args:
        vehicle: The connected mavlink object
        target_x: Target X coordinate in the image
        target_y: Target Y coordinate in the image
        camera_x: Camera center X coordinate
        camera_y: Camera center Y coordinate
        timeout: Maximum alignment time in seconds

    Returns:
        True if alignment was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Aligning drone to target")

        # Calculate offset
        offset_x = target_x - camera_x
        offset_y = target_y - camera_y

        # Define alignment threshold (pixels)
        threshold = 20

        # Start alignment timer
        start_time = time.time()

        while (abs(offset_x) > threshold or abs(offset_y) > threshold) and time.time() - start_time < timeout:
            logging.info(f"Target offset: X={offset_x}, Y={offset_y}")

            # Calculate velocity based on offset
            # Note: X offset maps to Y velocity, Y offset maps to X velocity in camera frame
            # Scale velocity based on how far we are from the target (proportional control)
            velocity_scale = 0.2  # m/s maximum speed
            velocity_x = velocity_scale * (offset_y / max(abs(offset_y), 100)) if abs(offset_y) > threshold else 0
            velocity_y = velocity_scale * (offset_x / max(abs(offset_x), 100)) if abs(offset_x) > threshold else 0

            logging.info(f"Adjustment velocity: X={velocity_x}, Y={velocity_y}")

            # Send velocity command
            send_ned_velocity(vehicle, velocity_x, velocity_y, 0, 1)

            # Wait for drone to move
            time.sleep(1)

            # Recalculate offset (this would come from detection thread in practice)
            # This is a stub - in a real implementation, you'd get updated coordinates
            # from the detection system
            offset_x = offset_x * 0.7  # Simulate getting closer
            offset_y = offset_y * 0.7  # Simulate getting closer

        if time.time() - start_time >= timeout:
            logging.warning("Alignment timed out")
            return False

        logging.info("Drone aligned to target")
        return True
    except Exception as e:
        logging.error(f"Error during target alignment: {str(e)}")
        return False

def lower_to_delivery_height(vehicle, target_height, speed=0.5):
    """
    Lower the drone to a delivery height.

    Args:
        vehicle: The connected mavlink object
        target_height: Target height in meters
        speed: Descent speed in m/s

    Returns:
        True if lowering was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Get current height
        state = get_vehicle_state(vehicle)
        if not state or state['altitude'] is None:
            logging.error("Could not get current altitude")
            return False

        current_height = state['altitude']

        logging.info(f"Lowering drone from {current_height}m to {target_height}m")

        # Calculate descent distance
        descent_distance = current_height - target_height
        if descent_distance <= 0:
            logging.warning("Already at or below target height")
            return True

        # Calculate descent time
        descent_time = descent_distance / speed

        # Send descent velocity command (positive Z is down)
        send_ned_velocity(vehicle, 0, 0, speed, descent_time)

        # Wait for drone to reach target height
        timeout = descent_time + 5  # Add safety margin
        start_time = time.time()

        while time.time() - start_time < timeout:
            state = get_vehicle_state(vehicle)
            if state and state['altitude'] is not None:
                current_alt = state['altitude']
                logging.info(f"Current altitude: {current_alt}m")

                if current_alt <= target_height + 0.5:  # Allow 0.5m tolerance
                    logging.info(f"Reached delivery height: {current_alt}m")
                    return True

            time.sleep(1)

        logging.warning("Lowering timed out")
        return False
    except Exception as e:
        logging.error(f"Error during lowering: {str(e)}")
        return False

def raise_to_safe_height(vehicle, target_height, speed=0.5):
    """
    Raise the drone to a safe height after delivery.

    Args:
        vehicle: The connected mavlink object
        target_height: Target height in meters
        speed: Ascent speed in m/s

    Returns:
        True if raising was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Get current height
        state = get_vehicle_state(vehicle)
        if not state or state['altitude'] is None:
            logging.error("Could not get current altitude")
            return False

        current_height = state['altitude']

        logging.info(f"Raising drone from {current_height}m to {target_height}m")

        # Calculate ascent distance
        ascent_distance = target_height - current_height
        if ascent_distance <= 0:
            logging.warning("Already at or above target height")
            return True

        # Calculate ascent time
        ascent_time = ascent_distance / speed

        # Send ascent velocity command (negative Z is up)
        send_ned_velocity(vehicle, 0, 0, -speed, ascent_time)

        # Wait for drone to reach target height
        timeout = ascent_time + 5  # Add safety margin
        start_time = time.time()

        while time.time() - start_time < timeout:
            state = get_vehicle_state(vehicle)
            if state and state['altitude'] is not None:
                current_alt = state['altitude']
                logging.info(f"Current altitude: {current_alt}m")

                if current_alt >= target_height - 0.5:  # Allow 0.5m tolerance
                    logging.info(f"Reached safe height: {current_alt}m")
                    return True

            time.sleep(1)

        logging.warning("Raising timed out")
        return False
    except Exception as e:
        logging.error(f"Error during raising: {str(e)}")
        return False

def mission_package_delivery(vehicle, altitude=10, model_path=None, delivery_height=2):
    """
    Execute a package delivery mission with landing at target.

    Args:
        vehicle: The connected mavlink object
        altitude: Cruising altitude in meters
        model_path: Path to the detection model
        delivery_height: Height to lower to for delivery

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Starting package delivery mission")

        # Initialize variables for detection results
        target_detected = False
        detection_center_x = None
        detection_center_y = None
        detection_thread_running = True

        # Load detection model
        model = load_detection_model(model_path)
        if not model:
            logging.error("Failed to load detection model")
            return False

        # Define detection thread function
        def detection_thread():
            nonlocal target_detected, detection_center_x, detection_center_y

            try:
                # Initialize camera
                cap = initialize_camera(0)
                if not cap:
                    logging.error("Failed to initialize camera")
                    return

                # Get camera center coordinates
                cam_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
                cam_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
                camera_center_x = cam_width / 2
                camera_center_y = cam_height / 2

                logging.info(f"Camera initialized. Resolution: {cam_width}x{cam_height}")

                # Run detection until thread is stopped
                while detection_thread_running:
                    # Capture frame
                    frame = capture_frame(cap)
                    if frame is None:
                        time.sleep(0.1)
                        continue

                    # Run detection on frame
                    results = run_detection(
                        model,
                        source=frame,
                        threshold=0.5,
                        save_results=False
                    )

                    # Process detection results
                    if results:
                        detections = process_detection_results(
                            [next(results)],
                            frame,
                            display=True
                        )

                        # Check if any object was detected
                        if detections:
                            # Use the first detection (highest confidence)
                            detection = detections[0]
                            target_detected = True
                            detection_center_x = detection['center'][0]
                            detection_center_y = detection['center'][1]

                            logging.info(f"Target detected at ({detection_center_x}, {detection_center_y})")
                        else:
                            target_detected = False
                            detection_center_x = None
                            detection_center_y = None

                    # Sleep briefly to reduce CPU usage
                    time.sleep(0.1)

                # Clean up resources
                close_camera(cap)

            except Exception as e:
                logging.error(f"Error in detection thread: {str(e)}")

        # Start detection thread
        det_thread = Thread(target=detection_thread)
        det_thread.daemon = True
        det_thread.start()

        # Wait for detection thread to initialize
        time.sleep(2)

        # First, arm and take off
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and take off")
            detection_thread_running = False
            return False

        # Start a search pattern (simple square for now)
        waypoints = [
            (10, 0),    # 10m North
            (10, 10),   # 10m North, 10m East
            (0, 10),    # 10m East
            (0, 0)      # Back to start
        ]

        # Search for target
        target_found = False

        for i, waypoint in enumerate(waypoints):
            logging.info(f"Navigating to search point {i+1}/{len(waypoints)}")

            success = navigate_to_waypoint(
                vehicle, waypoint, altitude, relative=True
            )

            if not success:
                logging.error(f"Failed to navigate to search point {i+1}")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Hover for 5 seconds at each waypoint to run detection
            logging.info(f"Reached search point {i+1}. Scanning for target")

            # Check for detections at this waypoint
            detection_start = time.time()
            while time.time() - detection_start < 5:
                if target_detected:
                    logging.info("Target detected! Preparing for delivery")
                    target_found = True
                    break

                time.sleep(0.5)

            if target_found:
                break

        # If target was found, align and deliver package
        if target_found and detection_center_x is not None and detection_center_y is not None:
            logging.info("Target found. Proceeding with delivery")

            # Align to target
            camera_center_x = 640 / 2  # Assuming 640x480 resolution
            camera_center_y = 480 / 2

            if not align_to_target(
                vehicle, detection_center_x, detection_center_y,
                camera_center_x, camera_center_y
            ):
                logging.error("Failed to align to target")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Lower to delivery height
            if not lower_to_delivery_height(vehicle, delivery_height):
                logging.error("Failed to lower to delivery height")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Deploy package
            logging.info("Deploying package")
            operate_claw(vehicle)
            time.sleep(2)

            # Raise back to safe height
            if not raise_to_safe_height(vehicle, altitude):
                logging.error("Failed to raise to safe height")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False
        else:
            logging.warning("Target not found during search pattern")

        # Return to launch
        logging.info("Mission complete. Returning to launch")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 60:  # 1 minute timeout
            # Get latest state
            state = get_vehicle_state(vehicle)
            if state:
                armed = state.get('armed', None)
                if armed is not None and not armed:
                    logging.info("Vehicle has disarmed")
                    break

                altitude = state.get('altitude', None)
                if altitude is not None:
                    logging.info(f"Altitude: {altitude} meters")
                    if altitude < 0.5:  # Close to ground
                        logging.info("Vehicle has landed")
                        break
            time.sleep(1)

        # Stop detection thread
        detection_thread_running = False
        det_thread.join(timeout=2)  # Wait for thread to finish

        logging.info("Package delivery mission completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during package delivery mission: {str(e)}")
        # Stop detection thread
        detection_thread_running = False
        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
        except:
            pass
        return False

def mission_package_drop(vehicle, altitude=10, model_path=None, drop_altitude=8):
    """
    Execute a package drop mission without lowering.

    Args:
        vehicle: The connected mavlink object
        altitude: Cruising altitude in meters
        model_path: Path to the detection model
        drop_altitude: Altitude at which to drop the package

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Starting package drop mission")

        # Initialize variables for detection results
        target_detected = False
        detection_center_x = None
        detection_center_y = None
        detection_thread_running = True

        # Load detection model
        model = load_detection_model(model_path)
        if not model:
            logging.error("Failed to load detection model")
            return False

        # Define detection thread function
        def detection_thread():
            nonlocal target_detected, detection_center_x, detection_center_y

            try:
                # Initialize camera
                cap = initialize_camera(0)
                if not cap:
                    logging.error("Failed to initialize camera")
                    return

                # Get camera center coordinates
                cam_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
                cam_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
                camera_center_x = cam_width / 2
                camera_center_y = cam_height / 2

                logging.info(f"Camera initialized. Resolution: {cam_width}x{cam_height}")

                # Run detection until thread is stopped
                while detection_thread_running:
                    # Capture frame
                    frame = capture_frame(cap)
                    if frame is None:
                        time.sleep(0.1)
                        continue

                    # Run detection on frame
                    results = run_detection(
                        model,
                        source=frame,
                        threshold=0.5,
                        save_results=False
                    )

                    # Process detection results
                    if results:
                        detections = process_detection_results(
                            [next(results)],
                            frame,
                            display=True
                        )

                        # Check if any object was detected
                        if detections:
                            # Use the first detection (highest confidence)
                            detection = detections[0]
                            target_detected = True
                            detection_center_x = detection['center'][0]
                            detection_center_y = detection['center'][1]

                            logging.info(f"Target detected at ({detection_center_x}, {detection_center_y})")
                        else:
                            target_detected = False
                            detection_center_x = None
                            detection_center_y = None

                    # Sleep briefly to reduce CPU usage
                    time.sleep(0.1)

                # Clean up resources
                close_camera(cap)

            except Exception as e:
                logging.error(f"Error in detection thread: {str(e)}")

        # Start detection thread
        det_thread = Thread(target=detection_thread)
        det_thread.daemon = True
        det_thread.start()

        # Wait for detection thread to initialize
        time.sleep(2)

        # First, arm and take off
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and take off")
            detection_thread_running = False
            return False

        # Start a search pattern (simple square for now)
        waypoints = [
            (10, 0),    # 10m North
            (10, 10),   # 10m North, 10m East
            (0, 10),    # 10m East
            (0, 0)      # Back to start
        ]

        # Search for target
        target_found = False

        for i, waypoint in enumerate(waypoints):
            logging.info(f"Navigating to search point {i+1}/{len(waypoints)}")

            success = navigate_to_waypoint(
                vehicle, waypoint, altitude, relative=True
            )

            if not success:
                logging.error(f"Failed to navigate to search point {i+1}")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Hover for 5 seconds at each waypoint to run detection
            logging.info(f"Reached search point {i+1}. Scanning for target")

            # Check for detections at this waypoint
            detection_start = time.time()
            while time.time() - detection_start < 5:
                if target_detected:
                    logging.info("Target detected! Preparing for drop")
                    target_found = True
                    break

                time.sleep(0.5)

            if target_found:
                break

        # If target was found, align and drop package
        if target_found and detection_center_x is not None and detection_center_y is not None:
            logging.info("Target found. Proceeding with package drop")

            # Align to target
            camera_center_x = 640 / 2  # Assuming 640x480 resolution
            camera_center_y = 480 / 2

            if not align_to_target(
                vehicle, detection_center_x, detection_center_y,
                camera_center_x, camera_center_y
            ):
                logging.error("Failed to align to target")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Drop package
            logging.info("Dropping package")
            operate_package_release(vehicle)
            time.sleep(2)
        else:
            logging.warning("Target not found during search pattern")

        # Return to launch
        logging.info("Mission complete. Returning to launch")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 60:  # 1 minute timeout
            # Get latest state
            state = get_vehicle_state(vehicle)
            if state:
                armed = state.get('armed', None)
                if armed is not None and not armed:
                    logging.info("Vehicle has disarmed")
                    break

                altitude = state.get('altitude', None)
                if altitude is not None:
                    logging.info(f"Altitude: {altitude} meters")
                    if altitude < 0.5:  # Close to ground
                        logging.info("Vehicle has landed")
                        break
            time.sleep(1)

        # Stop detection thread
        detection_thread_running = False
        det_thread.join(timeout=2)  # Wait for thread to finish

        logging.info("Package drop mission completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during package drop mission: {str(e)}")
        # Stop detection thread
        detection_thread_running = False
        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
        except:
            pass
        return False

def mission_target_localize(vehicle, altitude=10):
    """
    Execute a mission to locate ground control points.

    Args:
        vehicle: The connected mavlink object
        altitude: Cruising altitude in meters

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Starting target localization mission")

        # Initialize variables for GCP detection
        target_found = False
        target_type = None
        target_position = None
        detection_thread_running = True

        # Define GCP detection thread function
        def gcp_detection_thread():
            nonlocal target_found, target_type, target_position

            try:
                # Initialize camera
                cap = initialize_camera(0)
                if not cap:
                    logging.error("Failed to initialize camera")
                    return

                logging.info("Camera initialized for GCP detection")

                # Run detection until thread is stopped
                while detection_thread_running:
                    # Capture frame
                    frame = capture_frame(cap)
                    if frame is None:
                        time.sleep(0.1)
                        continue

                    # Detect GCP markers
                    results = detect_gcp_markers(frame, save_debug=True)

                    # Check for X-patterns (highest priority)
                    if len(results['x_patterns']) > 0:
                        x, y, w, h, conf = results['x_patterns'][0]
                        target_found = True
                        target_type = 'x_pattern'
                        target_position = (x + w/2, y + h/2)
                        logging.info(f"X-Pattern detected at {target_position} with confidence {conf}")

                    # Check for triangles in squares
                    elif len(results['tri_in_squares']) > 0:
                        x, y, w, h, count = results['tri_in_squares'][0]
                        target_found = True
                        target_type = 'triangles_in_square'
                        target_position = (x + w/2, y + h/2)
                        logging.info(f"Triangles in square detected at {target_position} with {count} triangles")

                    # Check for squares
                    elif len(results['squares']) > 0:
                        x, y, w, h, _ = results['squares'][0]
                        target_found = True
                        target_type = 'square'
                        target_position = (x + w/2, y + h/2)
                        logging.info(f"Square detected at {target_position}")

                    # Check for triangles
                    elif len(results['triangles']) > 0:
                        x, y, w, h, _ = results['triangles'][0]
                        target_found = True
                        target_type = 'triangle'
                        target_position = (x + w/2, y + h/2)
                        logging.info(f"Triangle detected at {target_position}")

                    else:
                        target_found = False
                        target_type = None
                        target_position = None

                    # Display the frame with detections
                    cv2.imshow("GCP Detection", results['display_frame'])
                    cv2.waitKey(1)

                    # Sleep briefly to reduce CPU usage
                    time.sleep(0.1)

                # Clean up resources
                close_camera(cap)
                cv2.destroyAllWindows()

            except Exception as e:
                logging.error(f"Error in GCP detection thread: {str(e)}")

        # Start detection thread
        det_thread = Thread(target=gcp_detection_thread)
        det_thread.daemon = True
        det_thread.start()

        # Wait for detection thread to initialize
        time.sleep(2)

        # First, arm and take off
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and take off")
            detection_thread_running = False
            return False

        # Start a search pattern
        waypoints = [
            (10, 0),    # 10m North
            (10, 10),   # 10m North, 10m East
            (0, 10),    # 10m East
            (0, 0)      # Back to start
        ]

        # Search for GCP targets
        for i, waypoint in enumerate(waypoints):
            logging.info(f"Navigating to search point {i+1}/{len(waypoints)}")

            success = navigate_to_waypoint(
                vehicle, waypoint, altitude, relative=True
            )

            if not success:
                logging.error(f"Failed to navigate to search point {i+1}")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Hover for 10 seconds at each waypoint to run detection
            logging.info(f"Reached search point {i+1}. Scanning for GCP targets")

            # Check for detections at this waypoint
            start_time = time.time()
            while time.time() - start_time < 10:
                if target_found:
                    logging.info(f"GCP target found: {target_type}")

                    # Record location if target is found
                    location = get_location(vehicle)
                    if location:
                        logging.info(f"GCP target location: Lat {location[0]}, Lon {location[1]}, Alt {location[2]}")
                        logging.info(f"Target pixel position: {target_position}")

                    # Hover for an additional 5 seconds to gather more data
                    time.sleep(5)
                    break

                time.sleep(0.5)

        # Return to launch
        logging.info("Mission complete. Returning to launch")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 60:  # 1 minute timeout
            # Get latest state
            state = get_vehicle_state(vehicle)
            if state:
                armed = state.get('armed', None)
                if armed is not None and not armed:
                    logging.info("Vehicle has disarmed")
                    break

                altitude = state.get('altitude', None)
                if altitude is not None:
                    logging.info(f"Altitude: {altitude} meters")
                    if altitude < 0.5:  # Close to ground
                        logging.info("Vehicle has landed")
                        break
            time.sleep(1)

        # Stop detection thread
        detection_thread_running = False
        det_thread.join(timeout=2)  # Wait for thread to finish

        logging.info("Target localization mission completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during target localization mission: {str(e)}")
        # Stop detection thread
        detection_thread_running = False
        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
        except:
            pass
        return False


--- missions\test_missions.py ---
"""
Test Missions Module
-----------------
Functions for testing drone components and functionality using pymavlink.
"""

import logging
import time
import cv2
from pymavlink import mavutil

from drone.connection import get_vehicle_state, print_vehicle_state, request_message_interval
from drone.navigation import (
    arm_vehicle, disarm_vehicle, set_mode, arm_and_takeoff,
    return_to_launch, check_if_armed, test_motors, get_altitude, get_location, wait_for_altitude_blocking
)
from detection.camera import test_camera_feed
from detection.models import load_detection_model, test_detection_model

def test_connection(vehicle):
    """
    Test the connection to the drone by checking its state and running diagnostics.

    Args:
        vehicle: The connected mavlink object

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Testing vehicle connection and running diagnostics")

        # Standard state check
        state = get_vehicle_state(vehicle)
        if state:
            print_vehicle_state(vehicle)
        else:
            logging.warning("Could not retrieve vehicle state")

        # Get comprehensive diagnostics
        from drone.connection import get_vehicle_diagnostics
        diagnostics = get_vehicle_diagnostics(vehicle, timeout=5)

        if diagnostics:
            logging.info("=== DRONE DIAGNOSTICS ===")

            # Connection info
            logging.info(f"System ID: {diagnostics['connection']['target_system']}")
            logging.info(f"Component ID: {diagnostics['connection']['target_component']}")
            logging.info(f"Connection: {diagnostics['connection']['connection_string']}")

            # Heartbeat status
            logging.info(f"Heartbeat received: {diagnostics['heartbeat_received']}")

            # Mode and armed status
            if diagnostics['mode']:
                logging.info(f"Current mode: {diagnostics['mode']}")
            logging.info(f"Armed: {diagnostics['armed']}")

            # Firmware info
            if diagnostics['firmware_version']:
                logging.info(f"Firmware version: {diagnostics['firmware_version']}")

            # GPS status
            if diagnostics['gps_status']:
                fix_type = diagnostics['gps_status']['fix_type']
                fix_type_name = "No GPS" if fix_type == 0 else \
                               "No Fix" if fix_type == 1 else \
                               "2D Fix" if fix_type == 2 else \
                               "3D Fix" if fix_type == 3 else \
                               f"Unknown ({fix_type})"
                logging.info(f"GPS status: {fix_type_name} ({diagnostics['gps_status']['satellites_visible']} satellites)")

            # Pre-arm status
            if diagnostics['pre_arm_status']:
                logging.info("Pre-arm checks status:")
                for msg in diagnostics['pre_arm_status']:
                    logging.info(f"  - {msg}")
            else:
                logging.info("No pre-arm check messages received.")

            # Important status text messages
            if diagnostics['status_text_messages']:
                logging.info("Important status messages:")
                for msg in diagnostics['status_text_messages'][-5:]:  # Show last 5 messages
                    logging.info(f"  - {msg}")

            logging.info("=========================")
        else:
            logging.warning("Could not retrieve diagnostic information")

        # Test for basic communication
        vehicle.mav.heartbeat_send(
            6,                  # Type: MAV_TYPE_GCS
            8,                  # Autopilot: MAV_AUTOPILOT_INVALID
            0,                  # Base mode: None
            0,                  # Custom mode: None
            0                   # System status: None
        )

        # Wait for heartbeat response
        msg = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=3)
        if not msg:
            logging.error("No heartbeat received from vehicle")
            return False

        logging.info(f"Received heartbeat from system {getattr(vehicle, 'target_system', 'Unknown')}, component {getattr(vehicle, 'target_component', 'Unknown')}")
        logging.info("Connection test completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during connection test: {str(e)}")
        return False

def test_arm(vehicle, duration=3):
    """
    Test arming and disarming the vehicle.

    Args:
        vehicle: The connected mavlink object
        duration: Duration to keep armed in seconds

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Testing arm functionality")

        # Set to GUIDED mode
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Import the direct MAVLink arming function
        from drone.navigation import arm_vehicle_mavlink, check_if_armed_simple

        # Try to arm using direct MAVLink
        logging.info("Arming vehicle with direct MAVLink method")
        if not arm_vehicle_mavlink(vehicle):
            logging.error("Failed to arm with direct MAVLink method")
            return False

        # Check if actually armed
        # armed = check_if_armed_simple(vehicle)
        armed = mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED
        logging.info(f"Arm state verification: {'ARMED' if armed else 'NOT ARMED'}")

        # If not armed but no exception was thrown, we'll proceed anyway
        if not armed:
            logging.warning("Arm command was accepted but vehicle doesn't appear armed")
            logging.info("Proceeding with test anyway")

        logging.info(f"Vehicle armed. Waiting for {duration} seconds...")
        time.sleep(duration)

        # Disarm with direct MAVLink
        logging.info("Disarming vehicle with direct MAVLink method")
        target_system = getattr(vehicle, 'target_system', 1)
        target_component = getattr(vehicle, 'target_component', 0)

        vehicle.mav.command_long_send(
            target_system,
            target_component,
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            0,                  # Confirmation
            0,                  # Param 1: 0 to disarm
            0,                  # Param 2: Normal disarm
            0, 0, 0, 0, 0       # Params 3-7 (not used)
        )

        # Wait a moment for disarm to take effect
        time.sleep(1)

        # Check disarm state
        armed = check_if_armed_simple(vehicle)
        if armed:
            logging.warning("Vehicle still appears to be armed after disarm command")
            # Not failing the test for this
        else:
            logging.info("Vehicle successfully disarmed")

        logging.info("Arm test completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during arm test: {str(e)}")

        # Try to disarm if there was an error
        try:
            vehicle.mav.command_long_send(
                getattr(vehicle, 'target_system', 1),
                getattr(vehicle, 'target_component', 0),
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                0, 0, 0, 0, 0, 0, 0, 0
            )
        except:
            pass

        return False

def test_takeoff(vehicle, altitude=3):
    """
    Test the drone takeoff and landing process.

    Args:
        vehicle: The connected mavlink object
        altitude: Target altitude in meters

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Testing takeoff to {altitude} meters")

        # First, arm and takeoff
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and takeoff")
            return False

        # Hover for 10 seconds
        logging.info("Hovering for 10 seconds")
        for i in range(10):
            logging.info(f"Hovering... {i+1}/10 seconds")
            print_vehicle_state(vehicle)
            time.sleep(1)

        # Return to launch
        logging.info("Testing return to launch")
        if not return_to_launch(vehicle):
            logging.error("Failed to return to launch")
            return False

        # Wait for landing and disarm
        logging.info("Waiting for landing")
        start_time = time.time()
        while check_if_armed(vehicle) and time.time() - start_time < 60:
            state = get_vehicle_state(vehicle)
            if state and 'altitude' in state:
                logging.info(f"Altitude: {state['altitude']} meters")
            time.sleep(1)

        if check_if_armed(vehicle):
            logging.warning("Vehicle still armed after RTL - trying manual disarm")
            disarm_vehicle(vehicle)

        logging.info("Takeoff test completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during takeoff test: {str(e)}")

        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
            time.sleep(5)
            disarm_vehicle(vehicle)
        except:
            pass

        return False

def test_camera(camera_id=0, duration=10):
    """
    Test the camera feed.

    Args:
        camera_id: Camera ID to use
        duration: Test duration in seconds

    Returns:
        True if test was successful, False otherwise
    """
    try:
        logging.info(f"Testing camera {camera_id} for {duration} seconds")
        return test_camera_feed(camera_id, duration)
    except Exception as e:
        logging.error(f"Error during camera test: {str(e)}")
        return False

def test_detection(model_path, test_source="0", duration=10):
    """
    Test the object detection model.

    Args:
        model_path: Path to the detection model
        test_source: Source for testing (0 for webcam, or path to image/video)
        duration: Test duration in seconds

    Returns:
        True if test was successful, False otherwise
    """
    try:
        logging.info(f"Testing detection model {model_path}")

        # Load the model
        model = load_detection_model(model_path)
        if not model:
            logging.error("Failed to load detection model")
            return False

        # Test the model
        return test_detection_model(model, test_source, duration=duration)
    except Exception as e:
        logging.error(f"Error during detection test: {str(e)}")
        return False

def test_motor(vehicle, throttle_percentage=15, duration_per_motor=1):
    """
    Test each motor individually.

    Args:
        vehicle: The connected mavlink object
        throttle_percentage: Throttle percentage (0-100)
        duration_per_motor: Duration to run each motor in seconds

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Testing motors at {throttle_percentage}% throttle for {duration_per_motor}s each")

        # Check if vehicle is in the air
        state = get_vehicle_state(vehicle)
        if state and state['armed']:
            is_flying = state['altitude'] > 0.5 if state['altitude'] is not None else True
            if is_flying:
                logging.error("Cannot run motor test while vehicle is armed or flying")
                return False

        # Run motor test
        if not test_motors(vehicle, throttle_percentage, duration_per_motor):
            logging.error("Motor test failed")
            return False

        logging.info("Motor test completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during motor test: {str(e)}")
        return False

def test_all(vehicle, model_path, altitude=3, camera_id=0):
    """
    Run all tests sequentially.

    Args:
        vehicle: The connected mavlink object
        model_path: Path to the detection model
        altitude: Target altitude in meters
        camera_id: Camera ID to use

    Returns:
        Dictionary with test results
    """
    results = {}

    # Test connection
    logging.info("=== STARTING CONNECTION TEST ===")
    results['connection'] = test_connection(vehicle)

    # Test camera
    logging.info("=== STARTING CAMERA TEST ===")
    results['camera'] = test_camera(camera_id)

    # Test detection
    logging.info("=== STARTING DETECTION TEST ===")
    results['detection'] = test_detection(model_path)

    # Test arm
    logging.info("=== STARTING ARM TEST ===")
    results['arm'] = test_arm(vehicle)

    # Test motors (CAUTION: only if safe)
    logging.info("=== SKIPPING MOTOR TEST (Run individually if needed) ===")
    results['motor'] = False

    # Test takeoff (last since it involves actual flight)
    logging.info("=== STARTING TAKEOFF TEST ===")
    results['takeoff'] = test_takeoff(vehicle, altitude)

    # Print summary
    logging.info("=== TEST SUMMARY ===")
    for test, result in results.items():
        status = "PASSED" if result else "FAILED"
        logging.info(f"Test '{test}': {status}")

    # Overall result
    results['all_passed'] = all(results.values())

    return results


# --- missions/test_missions.py ---
def test_incremental_takeoff(vehicle, max_altitude=3, increment=1):
    """
    Test takeoff in small increments with blocking behavior and audio feedback.

    Args:
        vehicle: The connected mavlink object
        max_altitude: Maximum target altitude in meters
        increment: Height increment in meters for each step

    Returns:
        True if test was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("=== BLOCKING INCREMENTAL TAKEOFF TEST ===")
        logging.info(f"Target: {max_altitude}m in {increment}m increments")

        # Run comprehensive pre-flight checks
        from drone.navigation import run_preflight_checks

        checks_passed, failure_reason = run_preflight_checks(vehicle)
        if not checks_passed:
            logging.error(f"Pre-flight checks failed: {failure_reason}")
            return False

        # Set to GUIDED mode
        logging.info("Setting mode to GUIDED")
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Arm the vehicle
        logging.info("Arming vehicle...")
        if not arm_vehicle(vehicle):
            logging.error("Failed to arm vehicle")
            return False

        # Wait for altitude to reset after arming
        logging.info("Waiting 2 seconds for altitude sensor to stabilize...")
        time.sleep(2)

        # Get baseline altitude
        baseline_msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=3)
        if baseline_msg:
            baseline_altitude = baseline_msg.relative_alt / 1000.0
            logging.info(f"Baseline altitude: {baseline_altitude:.3f}m")
        else:
            logging.warning("Could not get baseline altitude, proceeding anyway")
            baseline_altitude = 0.0

        # Initial takeoff to first increment
        first_target = increment
        logging.info(f"\n🚁 STEP 1: Initial takeoff to {first_target}m")

        # Send initial takeoff command
        vehicle.mav.command_long_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
            0,                  # Confirmation
            0, 0, 0, 0, 0, 0,   # Params 1-6 (not used)
            first_target        # Param 7: Altitude (in meters)
        )

        # BLOCKING wait for first altitude
        if not wait_for_altitude_blocking(vehicle, first_target, timeout=40, tolerance=0.15):
            logging.error(f"Failed to reach initial altitude {first_target}m")
            return_to_launch(vehicle)
            return False

        logging.info(f"✓ Successfully reached {first_target}m")
        logging.info("Stabilizing for 2 seconds...")
        time.sleep(2)

        # Incremental altitude increases
        current_target = first_target

        while current_target < max_altitude:
            next_target = min(current_target + increment, max_altitude)
            step_number = int(next_target / increment) + 1

            logging.info(f"\n🚁 STEP {step_number}: Climbing to {next_target}m")

            # Send altitude command
            if not command_altitude_precise(vehicle, next_target):
                logging.error(f"Failed to send altitude command for {next_target}m")
                return_to_launch(vehicle)
                return False

            # BLOCKING wait for next altitude
            if not wait_for_altitude_blocking(vehicle, next_target, timeout=30, tolerance=0.15):
                logging.error(f"Failed to reach altitude {next_target}m")
                return_to_launch(vehicle)
                return False

            logging.info(f"✓ Successfully reached {next_target}m")
            current_target = next_target

            # Stabilization pause between increments
            if current_target < max_altitude:
                logging.info("Stabilizing for 2 seconds...")
                time.sleep(2)

        # Final hover at maximum altitude
        logging.info(f"\n🎯 FINAL: Reached maximum altitude of {max_altitude}m")
        logging.info("Final hover for 5 seconds...")
        time.sleep(5)

        # Return to launch with blocking behavior
        logging.info("\n🏠 RETURN TO LAUNCH")
        logging.info("Commanding RTL...")

        if not return_to_launch(vehicle):
            logging.error("Failed to command RTL")
            return False

        # BLOCKING wait for landing with real-time feedback
        logging.info("Monitoring descent and landing...")
        print("-" * 50)

        landing_start = time.time()
        landing_timeout = 90  # 90 seconds for landing

        while time.time() - landing_start < landing_timeout:
            # Check if still armed (landing complete when disarmed)
            heartbeat = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=1)
            if heartbeat:
                armed = (heartbeat.base_mode & mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED) != 0

                # Get current altitude
                pos_msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=False)
                current_alt = pos_msg.relative_alt / 1000.0 if pos_msg else None

                timestamp = time.strftime("%H:%M:%S")
                armed_status = "ARMED" if armed else "DISARMED"
                alt_str = f"{current_alt:.3f}m" if current_alt is not None else "N/A"

                print(f"\r{timestamp} | Status: {armed_status} | Altitude: {alt_str}", end="", flush=True)

                if not armed:
                    print(f"\n✓ LANDING COMPLETE - Vehicle disarmed")
                    # play_beep()
                    break

                # Also check if very close to ground
                if current_alt is not None and current_alt < 0.3:
                    print(f"\n✓ NEAR GROUND - Altitude: {current_alt:.3f}m")

            time.sleep(0.5)

        # Final verification
        time.sleep(2)
        final_armed = check_if_armed(vehicle)
        if final_armed:
            logging.warning("Vehicle still armed after landing timeout - forcing disarm")
            disarm_vehicle(vehicle)

        logging.info("\n🎉 INCREMENTAL TAKEOFF TEST COMPLETED SUCCESSFULLY")
        return True

    except Exception as e:
        logging.error(f"Error during incremental takeoff test: {str(e)}")
        try:
            logging.warning("Attempting emergency return to launch")
            return_to_launch(vehicle)
            time.sleep(10)
            if check_if_armed(vehicle):
                disarm_vehicle(vehicle)
        except:
            pass
        return False

def command_altitude_precise(vehicle, target_altitude):
    """
    Send precise altitude command using position target.

    Args:
        vehicle: The connected mavlink object
        target_altitude: Target altitude in meters

    Returns:
        True if command sent successfully
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Get current location for position hold
        current_location = get_location(vehicle)
        if not current_location:
            logging.error("Could not get current location for altitude command")
            return False

        lat, lon, _ = current_location

        logging.info(f"Commanding altitude change to {target_altitude}m")

        # Send position target with only altitude change
        vehicle.mav.set_position_target_global_int_send(
            0,  # time_boot_ms (not used)
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
            0b0000111111111000,  # type_mask (only alt enabled, position and velocity ignored)
            int(lat * 1e7),      # lat_int
            int(lon * 1e7),      # lon_int
            target_altitude,     # alt (meters)
            0, 0, 0,            # vx, vy, vz (not used)
            0, 0, 0,            # afx, afy, afz (not used)
            0, 0                # yaw, yaw_rate (not used)
        )

        return True

    except Exception as e:
        logging.error(f"Error sending altitude command: {str(e)}")
        return False


def monitor_altitude_realtime(vehicle, duration=0, update_interval=0.2):
    """
    Ultra-responsive altitude monitoring with minimal delay.

    Args:
        vehicle: The connected mavlink object
        duration: Duration to monitor in seconds (0 = indefinite)

    Returns:
        True if monitoring completed successfully
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("Starting ULTRA-RESPONSIVE altitude monitoring")
        logging.info("Press Ctrl+C to stop monitoring")

        # Request maximum frequency streams
        vehicle.mav.request_data_stream_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_POSITION,
            20,  # 20 Hz - maximum
            1    # Start
        )

        start_time = time.time()
        last_altitude = None
        message_count = 0

        print("\n" + "="*80)
        print("ULTRA-RESPONSIVE ALTITUDE MONITORING")
        print("="*80)
        print("Time       | Relative Alt | Change    | Messages | Status")
        print("-"*80)

        while True:
            if duration > 0 and (time.time() - start_time) > duration:
                break

            # Process ALL available messages immediately
            while True:
                msg = vehicle.recv_match(blocking=False)
                if not msg:
                    break

                message_count += 1

                if msg.get_type() == "GLOBAL_POSITION_INT":
                    current_altitude = msg.relative_alt / 1000.0
                    current_time = time.strftime("%H:%M:%S.%f")[:-3]

                    # Calculate change
                    change_str = "---"
                    if last_altitude is not None:
                        change = current_altitude - last_altitude
                        if abs(change) > 0.001:  # Only show significant changes
                            change_str = f"{change:+.3f}m"

                    # Determine status based on change rate
                    if last_altitude is None:
                        status = "INIT"
                    elif abs(current_altitude - last_altitude) > 0.01:
                        status = "MOVING"
                    else:
                        status = "STABLE"

                    print(f"{current_time:<10} | {current_altitude:>9.3f}m | {change_str:>9} | {message_count:>8} | {status}")

                    last_altitude = current_altitude

            # Very minimal sleep - just enough to prevent 100% CPU
            time.sleep(0.001)  # 1ms

        print("\nUltra-responsive monitoring stopped")
        return True

    except KeyboardInterrupt:
        print("\nUltra-responsive monitoring stopped by user")
        return True
    except Exception as e:
        logging.error(f"Error during ultra-responsive monitoring: {str(e)}")
        return False


--- missions\waypoint.py ---
"""
Waypoint Missions Module
---------------------
Functions for executing waypoint-based drone missions using pymavlink.
"""

import logging
import time
from threading import Thread
import cv2
from pymavlink import mavutil

from drone.connection import get_vehicle_state  # Corrected import location
from drone.navigation import (
    arm_and_takeoff, check_if_armed_simple, disarm_vehicle, set_mode, get_location, get_distance_metres,
    get_location_metres, navigate_to_waypoint, return_to_launch,
    send_ned_velocity
)
from detection.models import load_detection_model, run_detection, process_detection_results
from detection.camera import initialize_camera, capture_frame, close_camera

# Default waypoints for testing (latitude, longitude)
DEFAULT_WAYPOINTS = [
    (35.722952, -120.767658),  # Example waypoint 1
    (35.723101, -120.767592),  # Example waypoint 2
    (35.723072, -120.767421),  # Example waypoint 3
    (35.722925, -120.767489)   # Example waypoint 4
]

# Default relative waypoints for testing (meters North, meters East)
DEFAULT_RELATIVE_WAYPOINTS = [
    (10, 0),    # 10m North
    (10, 10),   # 10m North, 10m East
    (0, 10),    # 10m East
    (0, 0)      # Back to start
]

def mission_waypoint(vehicle, altitude=10, waypoints=None, relative=False):
    """
    Execute a simple waypoint navigation mission.

    Args:
        vehicle: The connected mavlink object
        altitude: Target altitude in meters
        waypoints: List of waypoints to visit (lat, lon) or (dNorth, dEast) if relative
        relative: If True, waypoints are relative to starting position

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Set default waypoints if none provided
        if waypoints is None:
            waypoints = DEFAULT_RELATIVE_WAYPOINTS if relative else DEFAULT_WAYPOINTS

        logging.info(f"Starting waypoint mission with {len(waypoints)} waypoints at {altitude}m altitude")
        logging.info(f"Using {'relative' if relative else 'absolute'} waypoints")

        # First, arm and take off
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and take off")
            return False

        # Navigate to each waypoint
        original_location = get_location(vehicle)
        if not original_location and relative:
            logging.error("Failed to get current location for relative navigation")
            return_to_launch(vehicle)
            return False

        for i, waypoint in enumerate(waypoints):
            logging.info(f"Navigating to waypoint {i+1}/{len(waypoints)}")

            if relative:
                logging.info(f"Relative waypoint: {waypoint[0]}m North, {waypoint[1]}m East")
                success = navigate_to_waypoint(
                    vehicle, waypoint, altitude, relative=True
                )
            else:
                logging.info(f"Absolute waypoint: Lat {waypoint[0]}, Lon {waypoint[1]}")
                success = navigate_to_waypoint(
                    vehicle, waypoint, altitude, relative=False
                )

            if not success:
                logging.error(f"Failed to navigate to waypoint {i+1}")
                return_to_launch(vehicle)
                return False

            # Hover for 5 seconds at each waypoint
            logging.info(f"Reached waypoint {i+1}. Hovering for 5 seconds")
            time.sleep(5)

        # Return to launch
        logging.info("Mission complete. Returning to launch")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 60:  # 1 minute timeout
            # Get latest state
            state = get_vehicle_state(vehicle)
            if state:
                armed = state.get('armed', None)
                if armed is not None and not armed:
                    logging.info("Vehicle has disarmed")
                    break

                altitude = state.get('altitude', None)
                if altitude is not None:
                    logging.info(f"Altitude: {altitude} meters")
                    if altitude < 0.5:  # Close to ground
                        logging.info("Vehicle has landed")
                        break
            time.sleep(1)

        logging.info("Waypoint mission completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during waypoint mission: {str(e)}")
        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
        except:
            pass
        return False

def mission_waypoint_detect(vehicle, altitude=10, model_path=None, waypoints=None, relative=False):
    """
    Execute a waypoint navigation mission with object detection.

    Args:
        vehicle: The connected mavlink object
        altitude: Target altitude in meters
        model_path: Path to the detection model
        waypoints: List of waypoints to visit
        relative: If True, waypoints are relative to starting position

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        # Set default waypoints if none provided
        if waypoints is None:
            waypoints = DEFAULT_RELATIVE_WAYPOINTS if relative else DEFAULT_WAYPOINTS

        logging.info(f"Starting waypoint detection mission with {len(waypoints)} waypoints")

        # Initialize variables for detection results
        target_detected = False
        detection_center_x = None
        detection_center_y = None
        detection_thread_running = True

        # Load detection model
        model = load_detection_model(model_path)
        if not model:
            logging.error("Failed to load detection model")
            return False

        # Define detection thread function
        def detection_thread():
            nonlocal target_detected, detection_center_x, detection_center_y

            try:
                # Initialize camera
                cap = initialize_camera(0)
                if not cap:
                    logging.error("Failed to initialize camera")
                    return

                # Get camera center coordinates
                cam_width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
                cam_height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
                camera_center_x = cam_width / 2
                camera_center_y = cam_height / 2

                logging.info(f"Camera initialized. Resolution: {cam_width}x{cam_height}")

                # Run detection until thread is stopped
                while detection_thread_running:
                    # Capture frame
                    frame = capture_frame(cap)
                    if frame is None:
                        time.sleep(0.1)
                        continue

                    # Run detection on frame
                    results = run_detection(
                        model,
                        source=frame,
                        threshold=0.5,
                        save_results=False
                    )

                    # Process detection results
                    if results:
                        detections = process_detection_results(
                            [next(results)],
                            frame,
                            display=True
                        )

                        # Check if any object was detected
                        if detections:
                            # Use the first detection (highest confidence)
                            detection = detections[0]
                            target_detected = True
                            detection_center_x = detection['center'][0]
                            detection_center_y = detection['center'][1]

                            logging.info(f"Target detected at ({detection_center_x}, {detection_center_y})")
                        else:
                            target_detected = False
                            detection_center_x = None
                            detection_center_y = None

                    # Sleep briefly to reduce CPU usage
                    time.sleep(0.1)

                # Clean up resources
                close_camera(cap)

            except Exception as e:
                logging.error(f"Error in detection thread: {str(e)}")

        # Start detection thread
        det_thread = Thread(target=detection_thread)
        det_thread.daemon = True
        det_thread.start()

        # Wait for detection thread to initialize
        time.sleep(2)

        # First, arm and take off
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and take off")
            detection_thread_running = False
            return False

        # Navigate to each waypoint
        original_location = get_location(vehicle)
        if not original_location and relative:
            logging.error("Failed to get current location for relative navigation")
            detection_thread_running = False
            return_to_launch(vehicle)
            return False

        for i, waypoint in enumerate(waypoints):
            logging.info(f"Navigating to waypoint {i+1}/{len(waypoints)}")

            if relative:
                success = navigate_to_waypoint(
                    vehicle, waypoint, altitude, relative=True
                )
            else:
                success = navigate_to_waypoint(
                    vehicle, waypoint, altitude, relative=False
                )

            if not success:
                logging.error(f"Failed to navigate to waypoint {i+1}")
                detection_thread_running = False
                return_to_launch(vehicle)
                return False

            # Hover for 5 seconds at each waypoint to run detection
            logging.info(f"Reached waypoint {i+1}. Hovering for 5 seconds")

            # Check for detections at this waypoint
            detection_start = time.time()
            while time.time() - detection_start < 5:
                if target_detected:
                    logging.info("Target detected! Processing...")

                    # Handle the detection here
                    # For now, just log it
                    logging.info(f"Detected target at coordinates: ({detection_center_x}, {detection_center_y})")

                    # You could add code here to align to the target, drop a package, etc.

                    # For demo purposes, hover a bit longer when target is found
                    time.sleep(2)
                    break

                time.sleep(0.5)

        # Return to launch
        logging.info("Mission complete. Returning to launch")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 60:  # 1 minute timeout
            # Get latest state
            state = get_vehicle_state(vehicle)
            if state:
                armed = state.get('armed', None)
                if armed is not None and not armed:
                    logging.info("Vehicle has disarmed")
                    break

                altitude = state.get('altitude', None)
                if altitude is not None:
                    logging.info(f"Altitude: {altitude} meters")
                    if altitude < 0.5:  # Close to ground
                        logging.info("Vehicle has landed")
                        break
            time.sleep(1)

        # Stop detection thread
        detection_thread_running = False
        det_thread.join(timeout=2)  # Wait for thread to finish

        logging.info("Waypoint detection mission completed successfully")
        return True
    except Exception as e:
        logging.error(f"Error during waypoint detection mission: {str(e)}")
        # Stop detection thread
        detection_thread_running = False
        # Try to return to launch if there was an error
        try:
            return_to_launch(vehicle)
        except:
            pass
        return False

def follow_mission_file(vehicle, mission_file):
    """
    Load and execute a mission from a file.

    Args:
        vehicle: The connected mavlink object
        mission_file: Path to mission file

    Returns:
        True if mission was loaded and started successfully, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Loading mission from file: {mission_file}")

        # TODO: Implement mission file loading
        # This would typically involve parsing a mission file format (e.g., .waypoints, .mission)
        # and uploading the waypoints to the vehicle using MAVLink mission protocol

        # For now, just log that this feature is not implemented
        logging.warning("Mission file loading not implemented yet")
        return False
    except Exception as e:
        logging.error(f"Error loading mission file: {str(e)}")
        return False


def wait_for_waypoint_blocking(vehicle, target_lat, target_lon, target_altitude, timeout=45, tolerance=1.0):
    """
    Blocking wait for waypoint arrival with real-time feedback and altitude monitoring.

    Args:
        vehicle: The connected mavlink object
        target_lat: Target latitude
        target_lon: Target longitude
        target_altitude: Target altitude to maintain
        timeout: Maximum time to wait in seconds
        tolerance: Distance tolerance in meters

    Returns:
        True if waypoint reached, False if timeout
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Navigating to waypoint: {target_lat:.7f}, {target_lon:.7f}")

        # Request high-frequency position updates
        vehicle.mav.request_data_stream_send(
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_DATA_STREAM_POSITION,
            10,  # 10 Hz
            1    # Start
        )

        start_time = time.time()
        last_distance = None
        stable_count = 0
        required_stable_readings = 3
        target_location = (target_lat, target_lon, 0)
        last_altitude_correction = 0

        print(f"\nNavigating to waypoint...")
        print("Target: {:.7f}, {:.7f} at {:.1f}m".format(target_lat, target_lon, target_altitude))
        print("-" * 70)

        while time.time() - start_time < timeout:
            # Get current position
            current_location = get_location(vehicle)

            if current_location:
                current_lat, current_lon, current_alt = current_location

                # Calculate distance to target
                distance = get_distance_metres(current_location, target_location)

                # Calculate bearing for reference
                bearing = calculate_bearing(current_lat, current_lon, target_lat, target_lon)

                # Monitor altitude loss and correct if needed
                altitude_loss = target_altitude - current_alt
                if altitude_loss > 0.5 and time.time() - last_altitude_correction > 2:
                    logging.warning(f"Altitude loss detected: {altitude_loss:.2f}m, correcting...")

                    # Send altitude correction command
                    vehicle.mav.set_position_target_global_int_send(
                        0,  # time_boot_ms
                        vehicle.target_system,
                        vehicle.target_component,
                        mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
                        0b0000111111111000,  # type_mask (only alt enabled)
                        int(current_lat * 1e7),
                        int(current_lon * 1e7),
                        target_altitude,
                        0, 0, 0, 0, 0, 0, 0, 0
                    )
                    last_altitude_correction = time.time()

                # Check if within tolerance
                if distance <= tolerance:
                    stable_count += 1
                    status = f"ARRIVED ({stable_count}/{required_stable_readings})"
                else:
                    stable_count = 0
                    status = f"MOVING (bearing: {bearing:.0f}°)"

                # Real-time display with altitude
                timestamp = time.strftime("%H:%M:%S")
                alt_status = f"ALT: {current_alt:.2f}m"
                if altitude_loss > 0.3:
                    alt_status += f" (-{altitude_loss:.2f}m)"

                print(f"\r{timestamp} | Pos: {current_lat:.7f}, {current_lon:.7f} | {alt_status} | Dist: {distance:6.2f}m | {status}", end="", flush=True)

                # Check if we've reached waypoint with stability
                if stable_count >= required_stable_readings:
                    print(f"\n✓ WAYPOINT REACHED! (Final distance: {distance:.2f}m, altitude: {current_alt:.2f}m)")
                    return True

                last_distance = distance

            # Safety check - ensure still armed and in correct mode
            heartbeat = vehicle.recv_match(type='HEARTBEAT', blocking=False)
            if heartbeat:
                armed = mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED
                if not armed:
                    print(f"\n✗ Vehicle disarmed during waypoint navigation!")
                    return False

            time.sleep(0.2)  # 200ms update rate

        print(f"\n✗ Timeout reaching waypoint (final distance: {last_distance:.2f}m)" if last_distance else "\n✗ Timeout reaching waypoint")
        return False

    except Exception as e:
        logging.error(f"Error waiting for waypoint: {str(e)}")
        return False

def calculate_bearing(lat1, lon1, lat2, lon2):
    """
    Calculate bearing from point 1 to point 2.

    Returns:
        Bearing in degrees (0-360)
    """
    import math

    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    dlon_rad = math.radians(lon2 - lon1)

    y = math.sin(dlon_rad) * math.cos(lat2_rad)
    x = math.cos(lat1_rad) * math.sin(lat2_rad) - math.sin(lat1_rad) * math.cos(lat2_rad) * math.cos(dlon_rad)

    bearing_rad = math.atan2(y, x)
    bearing_deg = math.degrees(bearing_rad)

    return (bearing_deg + 360) % 360

def command_waypoint_precise(vehicle, target_lat, target_lon, altitude):
    """
    Send precise waypoint command using position target.

    Args:
        vehicle: The connected mavlink object
        target_lat: Target latitude
        target_lon: Target longitude
        altitude: Target altitude in meters

    Returns:
        True if command sent successfully
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info(f"Commanding waypoint: {target_lat:.7f}, {target_lon:.7f} at {altitude}m")

        # Send position target
        vehicle.mav.set_position_target_global_int_send(
            0,  # time_boot_ms (not used)
            vehicle.target_system,
            vehicle.target_component,
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
            0b0000111111111000,  # type_mask (position only)
            int(target_lat * 1e7),  # lat_int
            int(target_lon * 1e7),  # lon_int
            altitude,               # alt (meters)
            0, 0, 0,               # vx, vy, vz (not used)
            0, 0, 0,               # afx, afy, afz (not used)
            0, 0                   # yaw, yaw_rate (not used)
        )

        return True

    except Exception as e:
        logging.error(f"Error sending waypoint command: {str(e)}")
        return False

def mission_diamond_precision(vehicle, altitude=5):
    """
    Execute a precision diamond waypoint mission with blocking behavior.

    Args:
        vehicle: The connected mavlink object
        altitude: Flight altitude in meters

    Returns:
        True if mission was successful, False otherwise
    """
    if not vehicle:
        logging.error("No vehicle connection")
        return False

    try:
        logging.info("=== PRECISION DIAMOND WAYPOINT MISSION ===")
        logging.info(f"Flight altitude: {altitude}m")

        # Define diamond waypoints around your field
        diamond_waypoints = [
            # (35.3482145, -119.1048425),  # North point
            # (35.3482019, -119.1049813),  # West point
            (35.3481850,	-119.1049075), # New West
            #(35.3481795,	-119.1046447),
            #(35.3481817,	-119.1047332),
            # (35.3481708, -119.1048297),  # South point
            (35.3481795, -119.1046386),  # East point
        ] * 70

        # Run pre-flight checks
        from drone.navigation import run_preflight_checks
        checks_passed, failure_reason = run_preflight_checks(vehicle)
        if not checks_passed:
            logging.error(f"Pre-flight checks failed: {failure_reason}")
            return False

        # Set to GUIDED mode
        logging.info("Setting mode to GUIDED")
        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        # Arm and takeoff
        logging.info(f"🚁 TAKEOFF: Arming and taking off to {altitude}m")
        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to arm and takeoff")
            return False

        # Get home location for reference
        home_location = get_location(vehicle)
        if home_location:
            home_lat, home_lon, _ = home_location
            logging.info(f"Home position: {home_lat:.7f}, {home_lon:.7f}")
        else:
            logging.warning("Could not get home location")

        # Navigate to each waypoint in the diamond
        for i, (waypoint_lat, waypoint_lon) in enumerate(diamond_waypoints, 1):
            logging.info(f"\n📍 WAYPOINT {i}/{len(diamond_waypoints)}: Diamond Point {i}")

            # Send waypoint command
            if not command_waypoint_precise(vehicle, waypoint_lat, waypoint_lon, altitude):
                logging.error(f"Failed to send waypoint {i} command")
                return_to_launch(vehicle)
                return False

            # BLOCKING wait for waypoint arrival
            if not wait_for_waypoint_blocking(vehicle, waypoint_lat, waypoint_lon, altitude, timeout=60, tolerance=1.5):
                logging.error(f"Failed to reach waypoint {i}")
                return_to_launch(vehicle)
                return False

            logging.info(f"✓ Successfully reached waypoint {i}")

            # Brief pause at each waypoint (except the last one)
            if i < len(diamond_waypoints):
                logging.info("Stabilizing for 2 seconds...")
                time.sleep(2)

        # Quick pause at final waypoint
        logging.info(f"\n🎯 DIAMOND COMPLETE: All {len(diamond_waypoints)} waypoints reached")
        logging.info("Final stabilization for 1 second...")
        time.sleep(1)

        # Return to launch with blocking behavior
        logging.info("\n🏠 RETURN TO LAUNCH")
        logging.info("Commanding RTL...")

        if not return_to_launch(vehicle):
            logging.error("Failed to command RTL")
            return False

        # BLOCKING wait for landing with real-time feedback
        logging.info("Monitoring return and landing...")
        print("-" * 50)

        landing_start = time.time()
        landing_timeout = 90

        while time.time() - landing_start < landing_timeout:
            # Check armed status and altitude
            heartbeat = vehicle.recv_match(type='HEARTBEAT', blocking=True, timeout=1)
            if heartbeat:
                armed = mavutil.mavlink.MAV_MODE_FLAG_SAFETY_ARMED

                # Get current position and altitude
                pos_msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=False)
                if pos_msg:
                    current_alt = pos_msg.relative_alt / 1000.0
                    current_lat = pos_msg.lat / 1e7
                    current_lon = pos_msg.lon / 1e7

                    # Calculate distance to home if we have home location
                    dist_to_home = "N/A"
                    if home_location:
                        current_pos = (current_lat, current_lon, current_alt)
                        dist_to_home = f"{get_distance_metres(current_pos, home_location):.1f}m"
                else:
                    current_alt = None
                    dist_to_home = "N/A"

                timestamp = time.strftime("%H:%M:%S")
                armed_status = "ARMED" if armed else "DISARMED"
                alt_str = f"{current_alt:.3f}m" if current_alt is not None else "N/A"

                print(f"\r{timestamp} | Status: {armed_status} | Alt: {alt_str} | Home Dist: {dist_to_home}", end="", flush=True)

                if not armed:
                    print(f"\n✓ LANDING COMPLETE - Vehicle disarmed")
                    break

            time.sleep(0.5)

        # Final verification
        time.sleep(1)
        final_armed = check_if_armed_simple(vehicle)
        if final_armed:
            logging.warning("Vehicle still armed after landing timeout - forcing disarm")
            disarm_vehicle(vehicle)

        logging.info("\n🎉 DIAMOND WAYPOINT MISSION COMPLETED SUCCESSFULLY")
        return True

    except Exception as e:
        logging.error(f"Error during diamond waypoint mission: {str(e)}")
        try:
            logging.warning("Attempting emergency return to launch")
            return_to_launch(vehicle)
            time.sleep(10)
            if check_if_armed_simple(vehicle):
                disarm_vehicle(vehicle)
        except:
            pass
        return False

def clean_message_streams(vehicle):
    """
    Clean up all existing message streams to prevent interference.
    This fixes the degradation over time issue.
    """
    if not vehicle:
        return False

    try:
        logging.info("Cleaning up message streams...")

        # Stop all message intervals
        common_message_ids = [
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            mavutil.mavlink.MAVLINK_MSG_ID_GPS_RAW_INT,
            mavutil.mavlink.MAVLINK_MSG_ID_ATTITUDE,
            mavutil.mavlink.MAVLINK_MSG_ID_VFR_HUD,
            mavutil.mavlink.MAVLINK_MSG_ID_HEARTBEAT,
        ]

        for msg_id in common_message_ids:
            vehicle.mav.command_long_send(
                vehicle.target_system, vehicle.target_component,
                mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
                msg_id, 0, 0, 0, 0, 0, 0  # 0 = stop
            )

        # Stop all legacy data streams
        for stream_id in range(13):  # ArduPilot has streams 0-12
            vehicle.mav.request_data_stream_send(
                vehicle.target_system, vehicle.target_component,
                stream_id, 0, 0  # Rate 0, stop
            )

        # Clear message buffer
        start_time = time.time()
        while time.time() - start_time < 1.0:  # Clear for 1 second
            vehicle.recv_match(blocking=False)

        logging.info("Message streams cleaned")
        return True

    except Exception as e:
        logging.warning(f"Error cleaning message streams: {str(e)}")
        return False

def setup_optimized_position_stream(vehicle, rate_hz=5):
    """
    Set up position stream optimized for your setup.
    Uses conservative rate and single method to prevent conflicts.
    """
    if not vehicle:
        return False

    try:
        # First clean existing streams
        clean_message_streams(vehicle)

        # Wait for cleanup to take effect
        time.sleep(0.5)

        logging.info(f"Setting up optimized position stream at {rate_hz} Hz")

        # Use ONLY the message interval method (which works best on your system)
        interval_us = int(1000000 / rate_hz)

        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            interval_us, 0, 0, 0, 0, 0
        )

        # Wait for acknowledgment
        ack = vehicle.recv_match(type='COMMAND_ACK', blocking=True, timeout=2)
        if ack and ack.command == mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL:
            if ack.result == 0:
                logging.info("Position stream setup successful")
            else:
                logging.warning(f"Position stream setup ACK result: {ack.result}")

        # Test the stream briefly
        time.sleep(0.5)
        test_msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=2)
        if test_msg:
            lat = test_msg.lat / 1e7
            lon = test_msg.lon / 1e7
            alt = test_msg.relative_alt / 1000.0
            logging.info(f"Position stream test: {lat:.7f}, {lon:.7f}, {alt:.2f}m")
            return True
        else:
            logging.warning("Position stream test failed")
            return False

    except Exception as e:
        logging.error(f"Error setting up position stream: {str(e)}")
        return False

def get_location_single_request(vehicle, timeout=2):
    """
    Get location with single clean request - no sustained streaming.
    This prevents the degradation issue you're experiencing.
    """
    if not vehicle:
        return None

    try:
        # Clear buffer first
        while vehicle.recv_match(blocking=False):
            pass

        # Request ONE position update
        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            100000, 0, 0, 0, 0, 0  # 10 Hz for just this request
        )

        # Get the message
        msg = vehicle.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=timeout)

        # Stop the stream immediately
        vehicle.mav.command_long_send(
            vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL, 0,
            mavutil.mavlink.MAVLINK_MSG_ID_GLOBAL_POSITION_INT,
            0, 0, 0, 0, 0, 0  # Stop
        )

        if msg:
            lat = msg.lat / 1e7
            lon = msg.lon / 1e7
            alt = msg.relative_alt / 1000.0
            return (lat, lon, alt)
        else:
            return None

    except Exception as e:
        logging.warning(f"Error getting single location: {str(e)}")
        return None

def wait_for_waypoint_optimized(vehicle, target_lat, target_lon, target_altitude, timeout=60, tolerance=2.0):
    """
    Optimized waypoint waiting that works with your message rate patterns.
    Uses burst requests instead of sustained streaming.
    """
    if not vehicle:
        return False

    try:
        logging.info(f"Optimized navigation to: {target_lat:.7f}, {target_lon:.7f}")

        start_time = time.time()
        target_location = (target_lat, target_lon, 0)
        consecutive_good = 0
        required_good = 3
        last_distance = None
        check_interval = 1.0  # Check position every 1 second
        last_check = 0

        print(f"\nOptimized waypoint navigation...")
        print("Target: {:.7f}, {:.7f} at {:.1f}m".format(target_lat, target_lon, target_altitude))
        print("-" * 70)

        while time.time() - start_time < timeout:
            current_time = time.time()

            # Only check position at intervals to prevent stream degradation
            if current_time - last_check >= check_interval:
                # Get position with single clean request
                current_location = get_location_single_request(vehicle, timeout=2)
                last_check = current_time

                if current_location:
                    current_lat, current_lon, current_alt = current_location

                    # Calculate distance
                    distance = get_distance_metres(current_location, target_location)
                    bearing = calculate_bearing(current_lat, current_lon, target_lat, target_lon)

                    # Check altitude and correct if needed
                    altitude_error = target_altitude - current_alt
                    if abs(altitude_error) > 0.8:
                        logging.info(f"Altitude correction needed: {altitude_error:+.2f}m")

                        try:
                            vehicle.mav.set_position_target_global_int_send(
                                0, vehicle.target_system, vehicle.target_component,
                                mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
                                0b0000111111111000,  # Only altitude
                                int(current_lat * 1e7), int(current_lon * 1e7), target_altitude,
                                0, 0, 0, 0, 0, 0, 0, 0
                            )
                        except Exception as e:
                            logging.warning(f"Altitude correction failed: {str(e)}")

                    # Check if within tolerance
                    if distance <= tolerance:
                        consecutive_good += 1
                        status = f"ARRIVED ({consecutive_good}/{required_good})"
                    else:
                        consecutive_good = 0

                        # Show progress
                        if last_distance and distance < last_distance:
                            status = f"APPROACHING (↓{last_distance-distance:.1f}m, bearing {bearing:.0f}°)"
                        else:
                            status = f"MOVING (bearing {bearing:.0f}°)"

                    # Display with timestamp
                    timestamp = time.strftime("%H:%M:%S")
                    alt_display = f"ALT: {current_alt:.2f}m"
                    if abs(altitude_error) > 0.3:
                        alt_display += f" ({altitude_error:+.2f}m)"

                    print(f"{timestamp} | Pos: {current_lat:.7f}, {current_lon:.7f} | {alt_display} | Dist: {distance:6.2f}m | {status}")

                    # Check if waypoint reached
                    if consecutive_good >= required_good:
                        print(f"✓ WAYPOINT REACHED! (Final: {distance:.2f}m, alt: {current_alt:.2f}m)")
                        return True

                    last_distance = distance

                else:
                    print(f"{time.strftime('%H:%M:%S')} | ⚠️  Position request failed")

            # Brief sleep between checks
            time.sleep(0.2)

        print(f"❌ Timeout after {timeout}s (final distance: {last_distance:.2f}m)" if last_distance else f"❌ Timeout after {timeout}s")
        return False

    except Exception as e:
        logging.error(f"Error during optimized waypoint wait: {str(e)}")
        return False

def command_waypoint_clean(vehicle, target_lat, target_lon, altitude):
    """Send waypoint command with clean approach"""
    if not vehicle:
        return False

    try:
        logging.info(f"Commanding waypoint: {target_lat:.7f}, {target_lon:.7f} at {altitude}m")

        vehicle.mav.set_position_target_global_int_send(
            0, vehicle.target_system, vehicle.target_component,
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
            0b0000111111111000,  # Position only
            int(target_lat * 1e7), int(target_lon * 1e7), altitude,
            0, 0, 0, 0, 0, 0, 0, 0
        )

        time.sleep(0.1)
        return True

    except Exception as e:
        logging.error(f"Error sending waypoint: {str(e)}")
        return False

def mission_diamond_precision_fixed(vehicle, altitude=5, loops=1):
    """
    Diamond mission optimized for your specific setup.
    Fixes the message degradation issue.
    """
    if not vehicle:
        return False

    try:
        logging.info("=== OPTIMIZED DIAMOND MISSION (Fixed for Your Setup) ===")

        # Clean up any existing streams first
        clean_message_streams(vehicle)

        # Your waypoints
        diamond_waypoints = [
            # (35.3481850, -119.1049075),  # West point
            # (35.3481795, -119.1046386),  # East point
            # Closer Positions
            (35.3481866,	-119.1047372), #left
            (35.3481888,	-119.1048713), #right
        ] * loops

        # Pre-flight checks and takeoff (using your existing functions)
        from drone.navigation import run_preflight_checks, set_mode, arm_and_takeoff, return_to_launch, check_if_armed, disarm_vehicle

        checks_passed, failure_reason = run_preflight_checks(vehicle)
        if not checks_passed:
            logging.error(f"Pre-flight checks failed: {failure_reason}")
            return False

        if not set_mode(vehicle, "GUIDED"):
            logging.error("Failed to set GUIDED mode")
            return False

        if not arm_and_takeoff(vehicle, altitude):
            logging.error("Failed to takeoff")
            return False

        # Get home position
        home_location = get_location_single_request(vehicle, timeout=5)
        if home_location:
            logging.info(f"Home: {home_location[0]:.7f}, {home_location[1]:.7f}")

        # Navigate to waypoints
        for i, (lat, lon) in enumerate(diamond_waypoints, 1):
            logging.info(f"\n📍 WAYPOINT {i}/{len(diamond_waypoints)}")

            if not command_waypoint_clean(vehicle, lat, lon, altitude):
                logging.error(f"Failed to command waypoint {i}")
                return_to_launch(vehicle)
                return False

            if not wait_for_waypoint_optimized(vehicle, lat, lon, altitude, timeout=90, tolerance=2.0):
                logging.error(f"Failed to reach waypoint {i}")
                return_to_launch(vehicle)
                return False

            logging.info(f"✓ Waypoint {i} complete")
            if i < len(diamond_waypoints):
                time.sleep(2)

        # Return home
        logging.info("\n🏠 RETURNING HOME")
        return_to_launch(vehicle)

        # Wait for landing
        start_time = time.time()
        while time.time() - start_time < 120:
            if not check_if_armed(vehicle):
                logging.info("✓ Landed and disarmed")
                break
            time.sleep(2)

        # Final cleanup
        clean_message_streams(vehicle)

        logging.info("🎉 OPTIMIZED MISSION COMPLETE")
        return True

    except Exception as e:
        logging.error(f"Mission error: {str(e)}")
        try:
            clean_message_streams(vehicle)
            return_to_launch(vehicle)
        except:
            pass
        return False

